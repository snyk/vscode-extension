import * as htmlparser2 from 'htmlparser2';
import { ImportedModule } from '../../../../common/types';
import { ModuleParser } from './moduleParser';

class SupportedSources {
  static readonly PathBased = [
    'https://maxcdn.bootstrapcdn.com/',
    'https://yastatic.net/',
    'https://stackpath.bootstrapcdn.com/',
  ];
  static readonly AtBased = ['https://cdn.jsdelivr.net/', 'https://unpkg.com/'];

  static readonly JQuery = 'https://code.jquery.com/';
  static readonly AspNetCDN = 'https://ajax.aspnetcdn.com/ajax/';
}

export class HtmlParser extends ModuleParser {
  getModules(fileName: string, source: string): ImportedModule[] {
    const packages: ImportedModule[] = [];
    const parser = new htmlparser2.Parser(
      {
        onopentag: (name, attribs) => {
          if (
            name === 'script' &&
            attribs.src &&
            (attribs.type || 'javascript/text').toLowerCase() === 'javascript/text'
          ) {
            const pkg = this.getPackageFromUrl(attribs.src);

            if (pkg) {
              const [name, version] = pkg.split('@');

              const offsetLines = this.getOffsetLines(parser.startIndex, source);
              const currentLine = offsetLines.length;

              const currentLineOffsetLength = offsetLines[offsetLines.length - 1].length;
              const startCol = source.substring(parser.startIndex).indexOf(attribs.src) + currentLineOffsetLength;

              packages.push({
                loc: {
                  start: {
                    line: currentLine,
                    column: startCol,
                  },
                  end: {
                    line: currentLine,
                    column: startCol + attribs.src.length,
                  },
                },
                fileName,
                line: currentLine,
                name,
                version,
                string: attribs.src,
              });
            }
          }
        },
      },
      { decodeEntities: true },
    );

    parser.write(source);
    parser.end();

    return packages;
  }

  private getPackageFromUrl(url: string): string | undefined {
    let i = url.toLowerCase().indexOf('/ajax/libs/');
    url = url.replace(/(.slim)?(\.min)?.js$/, '');

    if (i !== -1) {
      i += '/ajax/libs/'.length;
      const pkg = url.substring(i);
      const [name, version = 'latest'] = pkg.split('/');
      return `${name}@${version}`;
    }

    const isPathBased = SupportedSources.PathBased.find(_ => url.toLowerCase().startsWith(_));
    if (isPathBased) {
      const pkg = url.substring(isPathBased.length);
      const seperator = pkg.includes('/') ? '/' : '-';
      const [name, version = 'latest'] = pkg.split(seperator);
      return `${name}@${version}`;
    }

    if (url.toLowerCase().startsWith(SupportedSources.JQuery)) {
      const pkg = url.substring(SupportedSources.JQuery.length);
      const [name, ...version] = pkg.split('-');
      return `${name}@${version.join('-')}`;
    }

    if (url.toLowerCase().startsWith(SupportedSources.AspNetCDN)) {
      const pkg = url.substring(SupportedSources.AspNetCDN.length);
      const [name, ...version] = pkg.split('-');
      return `${name.split('/').pop()}@${version.join('-')}`;
    }

    const isAtBased = SupportedSources.AtBased.find(_ => url.toLowerCase().startsWith(_));
    if (isAtBased) {
      const pkg = url
        .substring(isAtBased.length)
        .split('/')
        .find(str => str.includes('@'));

      return pkg;
    }

    return undefined;
  }

  private getOffsetLines(index: number, source: string) {
    return source.substring(0, index).split('\n');
  }
}
