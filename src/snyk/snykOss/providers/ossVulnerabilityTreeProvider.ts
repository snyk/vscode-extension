import _ from 'lodash';
import { Command, ThemeIcon, TreeItemCollapsibleState, Uri } from 'vscode';
import { OpenCommandIssueType, OpenIssueCommandArg } from '../../common/commands/types';
import { IConfiguration } from '../../common/configuration/configuration';
import { configuration } from '../../common/configuration/instance';
import { SNYK_OPEN_ISSUE_COMMAND } from '../../common/constants/commands';
import { SNYK_ANALYSIS_STATUS } from '../../common/constants/views';
import { Issue, IssueSeverity, OssIssueData, LsErrorMessage } from '../../common/languageServer/types';
import { IContextService } from '../../common/services/contextService';
import { IProductService } from '../../common/services/productService';
import { IViewManagerService } from '../../common/services/viewManagerService';
import { ProductIssueTreeProvider } from '../../common/views/issueTreeProvider';
import { TreeNode } from '../../common/views/treeNode';
import { IVSCodeLanguages } from '../../common/vscode/languages';
import { messages } from '../constants/messages';
import { getOssIssueCommandArg } from './ossIssueCommandHelper';
import { IFolderConfigs } from '../../common/configuration/folderConfigs';

export default class OssIssueTreeProvider extends ProductIssueTreeProvider<OssIssueData> {
  constructor(
    protected viewManagerService: IViewManagerService,
    protected contextService: IContextService,
    protected ossService: IProductService<OssIssueData>,
    protected configuration: IConfiguration,
    protected languages: IVSCodeLanguages,
    protected readonly folderConfigs: IFolderConfigs,
  ) {
    super(contextService, ossService, configuration, languages, folderConfigs);
  }

  getRootChildren(): TreeNode[] {
    if (!configuration.getFeaturesConfiguration()?.ossEnabled) {
      return [
        new TreeNode({
          text: SNYK_ANALYSIS_STATUS.OSS_DISABLED,
        }),
      ];
    }

    return super.getRootChildren();
  }

  override getResultNodes(): TreeNode[] {
    const nodes: TreeNode[] = [];

    for (const result of this.productService.result.entries()) {
      const folderPath = result[0];
      const folderResult = result[1];

      const uri = Uri.file(folderPath);
      const shortFolderPath = uri.path.split('/');
      const folderName = shortFolderPath.pop() || uri.path;

      let folderVulnCount = 0;

      if (folderResult instanceof Error && folderResult.message === LsErrorMessage.repositoryInvalidError.toString()) {
        nodes.push(this.getFaultyRepositoryErrorTreeNode(folderName, folderResult.toString()));
        continue;
      }

      if (folderResult instanceof Error) {
        nodes.push(this.getErrorEncounteredTreeNode(folderName));
        continue;
      }

      const folderSeverityCounts = this.initSeverityCounts();
      const fileNodes: TreeNode[] = [];

      // Group issues by file
      const fileVulns = _.groupBy(folderResult, v => v.filePath);

      for (const file in fileVulns) {
        const fileIssues = fileVulns[file];
        const uri = Uri.file(file);
        const filePath = uri.path.split('/');
        const filename = filePath.pop() || uri.path;
        const dir = filePath.pop();

        const fileSeverityCounts = this.initSeverityCounts();

        // Remove duplicate issues
        const uniqueIssues = fileIssues.filter(
          (issue, index, self) => index === self.findIndex(t => t.id === issue.id),
        );

        const filteredIssues = this.filterIssues(uniqueIssues);

        // Group issues by package and version
        const packageGroupedIssues = _.groupBy(
          filteredIssues, 
          issue => `${issue.additionalData.packageName}@${issue.additionalData.version}`
        );

        const packageNodes: TreeNode[] = Object.entries(packageGroupedIssues).map(([packageVersion, issues]) => {
          const packageVulnerabilityNodes: TreeNode[] = this.filterVisibleIssues(issues).map(
            (issue: Issue<OssIssueData>) => {
              fileSeverityCounts[issue.severity] += 1;
              folderVulnCount++;

              return new TreeNode({
                text: issue.title,
                icon: ProductIssueTreeProvider.getSeverityIcon(issue.severity),
                internal: {
                  severity: ProductIssueTreeProvider.getSeverityComparatorIndex(issue.severity),
                },
                command: this.getOpenIssueCommand(issue, folderPath, '', filteredIssues),
              });
            }
          );

          // Sort vulnerability nodes by severity
          packageVulnerabilityNodes.sort(this.compareNodes);

          // Determine package severity based on highest severity issue
          const packageSeverity = ProductIssueTreeProvider.getHighestSeverity(
            this.initSeverityCounts(packageVulnerabilityNodes.map(node => 
              node.internal?.severity || 0
            ))
          );

          return new TreeNode({
            text: packageVersion,
            description: `${packageVulnerabilityNodes.length} ${packageVulnerabilityNodes.length === 1 ? 'issue' : 'issues'}`,
            icon: ProductIssueTreeProvider.getSeverityIcon(packageSeverity),
            children: packageVulnerabilityNodes,
            internal: {
              nIssues: packageVulnerabilityNodes.length,
              severity: ProductIssueTreeProvider.getSeverityComparatorIndex(packageSeverity),
            },
          });
        });

        if (packageNodes.length === 0) {
          continue;
        }

        // Sort package nodes by severity
        packageNodes.sort(this.compareNodes);

        const fileSeverity = ProductIssueTreeProvider.getHighestSeverity(fileSeverityCounts);
        folderSeverityCounts[fileSeverity] += 1;

        // Create file node with package groups as children
        const fileNode = new TreeNode({
          text: filename,
          description: this.getIssueDescriptionText(dir, folderVulnCount),
          icon: filename === 'package.json' ? new ThemeIcon('folder-library') : ProductIssueTreeProvider.getSeverityIcon(fileSeverity),
          children: packageNodes,
          collapsed: fileNodes.length === 0 
          ? TreeItemCollapsibleState.Expanded 
          : TreeItemCollapsibleState.Collapsed,
          internal: {
            nIssues: folderVulnCount,
            severity: ProductIssueTreeProvider.getSeverityComparatorIndex(fileSeverity),
          },
        });
        fileNodes.push(fileNode);
      }

      fileNodes.sort(this.compareNodes);

      const folderSeverity = ProductIssueTreeProvider.getHighestSeverity(folderSeverityCounts);

      const baseBranchNode = this.getBaseBranch(uri.fsPath);
      if (folderVulnCount == 0) {
        this.addBaseBranchNode(baseBranchNode, nodes);
        continue;
      }

      // Flatten results if single workspace folder
      if (this.productService.result.size === 1) {
        this.addBaseBranchNode(baseBranchNode, nodes);
        nodes.push(...fileNodes);
      } else {
        const folderNode = new TreeNode({
          text: folderName,
          description: this.getIssueDescriptionText(folderName, folderVulnCount),
          icon: ProductIssueTreeProvider.getSeverityIcon(folderSeverity),
          children: fileNodes,
          internal: {
            nIssues: folderVulnCount,
            severity: ProductIssueTreeProvider.getSeverityComparatorIndex(folderSeverity),
          },
        });
        this.addBaseBranchNode(baseBranchNode, fileNodes);
        nodes.push(folderNode);
      }
    }

    return nodes;
  }

  // Utility method to initialize severity counts
  protected initSeverityCounts(severities?: number[]): Record<IssueSeverity, number> {
    const counts: Record<IssueSeverity, number> = {
      [IssueSeverity.Critical]: 0,
      [IssueSeverity.High]: 0,
      [IssueSeverity.Medium]: 0,
      [IssueSeverity.Low]: 0,
    };

    // If severities provided, count their occurrences
    if (severities) {
      severities.forEach(severity => {
        const issueLevel = this.getSeverityFromComparatorIndex(severity);
        if (issueLevel) {
          counts[issueLevel]++;
        }
      });
    }

    return counts;
  }

  // Helper method to convert comparator index back to severity
  private getSeverityFromComparatorIndex(index: number): IssueSeverity | undefined {
    const severityMap: Record<number, IssueSeverity> = {
      0: IssueSeverity.Low,
      1: IssueSeverity.Medium,
      2: IssueSeverity.High,
      3: IssueSeverity.Critical,
    };
    return severityMap[index];
  }




  onDidChangeTreeData = this.viewManagerService.refreshOssViewEmitter.event;

  shouldShowTree(): boolean {
    return this.contextService.shouldShowOssAnalysis;
  }

  getIssueDescriptionText(dir: string | undefined, issueCount: number): string | undefined {
    return `${dir} - ${issueCount} ${issueCount === 1 ? 'vulnerability' : 'vulnerabilities'}`;
  }

  getIssueFoundText(nIssues: number, _: number): string {
    if (!nIssues) {
      return 'âœ… Congrats! No issues found!';
    }
    return `Snyk found ${nIssues} issue${nIssues === 1 ? '' : 's'}`;
  }

  filterIssues(issues: Issue<OssIssueData>[]): Issue<OssIssueData>[] {
    return issues.filter(vuln => {
      switch (vuln.severity) {
        case IssueSeverity.Critical:
          return this.configuration.severityFilter.critical;
        case IssueSeverity.High:
          return this.configuration.severityFilter.high;
        case IssueSeverity.Medium:
          return this.configuration.severityFilter.medium;
        case IssueSeverity.Low:
          return this.configuration.severityFilter.low;
        default:
          return true;
      }
    });
  }

  getRunTestMessage = () => messages.treeView.runTest;

  getIssueTitle = (issue: Issue<OssIssueData>) => issue.title;

  getIssueRange = () => undefined;

  getOpenIssueCommand(
    issue: Issue<OssIssueData>,
    folderPath: string,
    _filePath: string,
    filteredIssues: Issue<OssIssueData>[],
  ): Command {
    return {
      command: SNYK_OPEN_ISSUE_COMMAND,
      title: '',
      arguments: [
        {
          issueType: OpenCommandIssueType.OssVulnerability,
          issue: getOssIssueCommandArg(issue, folderPath, filteredIssues),
        } as OpenIssueCommandArg,
      ],
    };
  }
}
