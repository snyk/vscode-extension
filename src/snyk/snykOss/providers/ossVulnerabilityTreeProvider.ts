import _ from 'lodash';
import { Command, Uri } from 'vscode';
import { OpenCommandIssueType, OpenIssueCommandArg } from '../../common/commands/types';
import { IConfiguration } from '../../common/configuration/configuration';
import { configuration } from '../../common/configuration/instance';
import { SNYK_OPEN_ISSUE_COMMAND } from '../../common/constants/commands';
import { SNYK_ANALYSIS_STATUS } from '../../common/constants/views';
import { Issue, IssueSeverity, OssIssueData, LsErrorMessage } from '../../common/languageServer/types';
import { IContextService } from '../../common/services/contextService';
import { IProductService } from '../../common/services/productService';
import { IViewManagerService } from '../../common/services/viewManagerService';
import { ProductIssueTreeProvider } from '../../common/views/issueTreeProvider';
import { TreeNode } from '../../common/views/treeNode';
import { IVSCodeLanguages } from '../../common/vscode/languages';
import { messages } from '../constants/messages';
import { getOssIssueCommandArg } from './ossIssueCommandHelper';
import { IFolderConfigs } from '../../common/configuration/folderConfigs';

export default class OssIssueTreeProvider extends ProductIssueTreeProvider<OssIssueData> {
  constructor(
    protected viewManagerService: IViewManagerService,
    protected contextService: IContextService,
    protected ossService: IProductService<OssIssueData>,
    protected configuration: IConfiguration,
    protected languages: IVSCodeLanguages,
    protected readonly folderConfigs: IFolderConfigs,
  ) {
    super(contextService, ossService, configuration, languages, folderConfigs);
  }

  getRootChildren(): TreeNode[] {
    if (!configuration.getFeaturesConfiguration()?.ossEnabled) {
      return [
        new TreeNode({
          text: SNYK_ANALYSIS_STATUS.OSS_DISABLED,
        }),
      ];
    }

    return super.getRootChildren();
  }

  override getResultNodes(): TreeNode[] {
    const nodes: TreeNode[] = [];

    for (const result of this.productService.result.entries()) {
      const folderPath = result[0];
      const folderResult = result[1];

      const uri = Uri.file(folderPath);
      const shortFolderPath = uri.path.split('/');
      const folderName = shortFolderPath.pop() || uri.path;

      let folderVulnCount = 0;

      if (folderResult instanceof Error && folderResult.message === LsErrorMessage.repositoryInvalidError.toString()) {
        nodes.push(this.getFaultyRepositoryErrorTreeNode(folderName, folderResult.toString()));
        continue;
      }

      if (folderResult instanceof Error) {
        nodes.push(this.getErrorEncounteredTreeNode(folderName));
        continue;
      }

      const folderSeverityCounts = this.initSeverityCounts();
      const fileNodes: TreeNode[] = [];

      const fileVulns = _.groupBy(folderResult, v => v.filePath);

      for (const file in fileVulns) {
        const fileIssues = fileVulns[file];
        const uri = Uri.file(file);
        const filePath = uri.path.split('/');
        const filename = filePath.pop() || uri.path;
        const dir = filePath.pop();

        const fileSeverityCounts = this.initSeverityCounts();

        const uniqueIssues = fileIssues.filter(
          (issue, index, self) => index === self.findIndex(t => t.id === issue.id),
        );

        const filteredIssues = this.filterIssues(uniqueIssues);

        const vulnerabilityNodes: TreeNode[] = this.filterVisibleIssues(filteredIssues).map(
          (issue: Issue<OssIssueData>) => {
            fileSeverityCounts[issue.severity] += 1;
            folderVulnCount++;

            return new TreeNode({
              text: `${issue.additionalData.packageName}@${issue.additionalData.version} - ${issue.title}`,
              icon: ProductIssueTreeProvider.getSeverityIcon(issue.severity),
              internal: {
                severity: ProductIssueTreeProvider.getSeverityComparatorIndex(issue.severity),
              },
              command: this.getOpenIssueCommand(issue, folderPath, '', filteredIssues),
            });
          },
        );

        if (vulnerabilityNodes.length === 0) {
          continue;
        }

        vulnerabilityNodes.sort(this.compareNodes);

        const fileSeverity = ProductIssueTreeProvider.getHighestSeverity(fileSeverityCounts);
        folderSeverityCounts[fileSeverity] += 1;

        // append file node
        const fileNode = new TreeNode({
          text: filename,
          description: this.getIssueDescriptionText(dir, vulnerabilityNodes.length),
          icon: ProductIssueTreeProvider.getSeverityIcon(fileSeverity),
          children: vulnerabilityNodes,
          internal: {
            nIssues: vulnerabilityNodes.length,
            severity: ProductIssueTreeProvider.getSeverityComparatorIndex(fileSeverity),
          },
        });
        fileNodes.push(fileNode);
      }

      fileNodes.sort(this.compareNodes);

      const folderSeverity = ProductIssueTreeProvider.getHighestSeverity(folderSeverityCounts);

      const baseBranchNode = this.getBaseBranch(uri.fsPath);
      if (folderVulnCount == 0) {
        this.addBaseBranchNode(baseBranchNode, nodes);
        continue;
      }
      // flatten results if single workspace folder
      if (this.productService.result.size === 1) {
        this.addBaseBranchNode(baseBranchNode, nodes);
        nodes.push(...fileNodes);
      } else {
        const folderNode = new TreeNode({
          text: folderName,
          description: this.getIssueDescriptionText(folderName, folderVulnCount),
          icon: ProductIssueTreeProvider.getSeverityIcon(folderSeverity),
          children: fileNodes,
          internal: {
            nIssues: folderVulnCount,
            severity: ProductIssueTreeProvider.getSeverityComparatorIndex(folderSeverity),
          },
        });
        this.addBaseBranchNode(baseBranchNode, fileNodes);
        nodes.push(folderNode);
      }
    }

    return nodes;
  }

  onDidChangeTreeData = this.viewManagerService.refreshOssViewEmitter.event;

  shouldShowTree(): boolean {
    return this.contextService.shouldShowOssAnalysis;
  }

  getIssueDescriptionText(dir: string | undefined, issueCount: number): string | undefined {
    return `${dir} - ${issueCount} ${issueCount === 1 ? 'vulnerability' : 'vulnerabilities'}`;
  }

  getIssueFoundText(nIssues: number, _: number): string {
    if (!nIssues) {
      return 'âœ… Congrats! No issues found!';
    }
    return `Snyk found ${nIssues} issue${nIssues === 1 ? '' : 's'}`;
  }

  filterIssues(issues: Issue<OssIssueData>[]): Issue<OssIssueData>[] {
    return issues.filter(vuln => {
      switch (vuln.severity) {
        case IssueSeverity.Critical:
          return this.configuration.severityFilter.critical;
        case IssueSeverity.High:
          return this.configuration.severityFilter.high;
        case IssueSeverity.Medium:
          return this.configuration.severityFilter.medium;
        case IssueSeverity.Low:
          return this.configuration.severityFilter.low;
        default:
          return true;
      }
    });
  }

  getRunTestMessage = () => messages.treeView.runTest;

  getIssueTitle = (issue: Issue<OssIssueData>) => issue.title;

  getIssueRange = () => undefined;

  getOpenIssueCommand(
    issue: Issue<OssIssueData>,
    folderPath: string,
    _filePath: string,
    filteredIssues: Issue<OssIssueData>[],
  ): Command {
    return {
      command: SNYK_OPEN_ISSUE_COMMAND,
      title: '',
      arguments: [
        {
          issueType: OpenCommandIssueType.OssVulnerability,
          issue: getOssIssueCommandArg(issue, folderPath, filteredIssues),
        } as OpenIssueCommandArg,
      ],
    };
  }
}
