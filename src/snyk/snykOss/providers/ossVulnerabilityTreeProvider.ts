import _ from 'lodash';
import * as marked from 'marked';
import { Command, Uri } from 'vscode';
import { OpenCommandIssueType, OpenIssueCommandArg } from '../../common/commands/types';
import { IConfiguration } from '../../common/configuration/configuration';
import { configuration } from '../../common/configuration/instance';
import { SNYK_OPEN_ISSUE_COMMAND } from '../../common/constants/commands';
import { SNYK_ANALYSIS_STATUS } from '../../common/constants/views';
import { Issue, IssueSeverity, OssIssueData } from '../../common/languageServer/types';
import { IContextService } from '../../common/services/contextService';
import { IProductService } from '../../common/services/productService';
import { IViewManagerService } from '../../common/services/viewManagerService';
import { ProductIssueTreeProvider } from '../../common/views/issueTreeProvider';
import { TreeNode } from '../../common/views/treeNode';
import { IVSCodeLanguages } from '../../common/vscode/languages';
import { messages } from '../constants/messages';
import { OssIssueCommandArg } from '../interfaces';

export default class OssIssueTreeProvider extends ProductIssueTreeProvider<OssIssueData> {
  constructor(
    protected viewManagerService: IViewManagerService,
    protected contextService: IContextService,
    protected ossService: IProductService<OssIssueData>,
    protected configuration: IConfiguration,
    protected languages: IVSCodeLanguages,
  ) {
    super(contextService, ossService, configuration, languages);
  }

  getRootChildren(): TreeNode[] {
    if (!configuration.getFeaturesConfiguration()?.ossEnabled) {
      return [
        new TreeNode({
          text: SNYK_ANALYSIS_STATUS.OSS_DISABLED,
        }),
      ];
    }

    return super.getRootChildren();
  }

  override getResultNodes(): [TreeNode[], number] {
    const nodes: TreeNode[] = [];
    let totalVulnCount = 0;

    for (const result of this.productService.result.entries()) {
      const folderPath = result[0];
      const folderResult = result[1];

      const uri = Uri.file(folderPath);
      const shortFolderPath = uri.path.split('/');
      const folderName = shortFolderPath.pop() || uri.path;

      let folderVulnCount = 0;
      if (folderResult instanceof Error) {
        nodes.push(this.getErrorEncounteredTreeNode(folderName));
        continue;
      }

      const folderSeverityCounts = this.initSeverityCounts();
      const fileNodes: TreeNode[] = [];

      const fileVulns = _.groupBy(folderResult, v => v.filePath);

      for (const file in fileVulns) {
        const fileIssues = fileVulns[file];
        const uri = Uri.file(file);
        const filePath = uri.path.split('/');
        const filename = filePath.pop() || uri.path;
        const dir = filePath.pop();

        const fileSeverityCounts = this.initSeverityCounts();

        const uniqueIssues = fileIssues.filter(
          (issue, index, self) => index === self.findIndex(t => t.id === issue.id),
        );

        const filteredIssues = this.filterIssues(uniqueIssues);

        const vulnerabilityNodes: TreeNode[] = filteredIssues.map((issue: Issue<OssIssueData>) => {
          fileSeverityCounts[issue.severity] += 1;
          totalVulnCount++;
          folderVulnCount++;

          return new TreeNode({
            text: `${issue.additionalData.packageName}@${issue.additionalData.version} - ${issue.title}`,
            icon: ProductIssueTreeProvider.getSeverityIcon(issue.severity),
            internal: {
              severity: ProductIssueTreeProvider.getSeverityComparatorIndex(issue.severity),
            },
            command: this.getOpenIssueCommand(issue, '', '', filteredIssues),
          });
        });

        if (vulnerabilityNodes.length === 0) {
          continue;
        }

        vulnerabilityNodes.sort(this.compareNodes);

        const fileSeverity = ProductIssueTreeProvider.getHighestSeverity(fileSeverityCounts);
        folderSeverityCounts[fileSeverity] += 1;

        // append file node
        const fileNode = new TreeNode({
          text: filename,
          description: this.getIssueDescriptionText(dir, vulnerabilityNodes.length),
          icon: ProductIssueTreeProvider.getSeverityIcon(fileSeverity),
          children: vulnerabilityNodes,
          internal: {
            nIssues: vulnerabilityNodes.length,
            severity: ProductIssueTreeProvider.getSeverityComparatorIndex(fileSeverity),
          },
        });
        fileNodes.push(fileNode);
      }

      fileNodes.sort(this.compareNodes);

      const folderSeverity = ProductIssueTreeProvider.getHighestSeverity(folderSeverityCounts);

      if (folderVulnCount == 0) {
        continue;
      }

      // flatten results if single workspace folder
      if (this.productService.result.size == 1) {
        nodes.push(...fileNodes);
      } else {
        const folderNode = new TreeNode({
          text: folderName,
          description: this.getIssueDescriptionText(folderName, folderVulnCount),
          icon: ProductIssueTreeProvider.getSeverityIcon(folderSeverity),
          children: fileNodes,
          internal: {
            nIssues: folderVulnCount,
            severity: ProductIssueTreeProvider.getSeverityComparatorIndex(folderSeverity),
          },
        });
        nodes.push(folderNode);
      }
    }

    return [nodes, totalVulnCount];
  }

  onDidChangeTreeData = this.viewManagerService.refreshOssViewEmitter.event;

  shouldShowTree(): boolean {
    return this.contextService.shouldShowOssAnalysis;
  }

  getIssueDescriptionText(dir: string | undefined, issueCount: number): string | undefined {
    return `${dir} - ${issueCount} ${issueCount === 1 ? 'vulnerability' : 'vulnerabilities'}`;
  }

  getIssueFoundText(nIssues: number): string {
    return `Snyk found ${
      !nIssues ? 'no vulnerabilities! âœ…' : `${nIssues} ${nIssues === 1 ? 'vulnerability' : 'vulnerabilities'}`
    }`;
  }

  filterIssues(issues: Issue<OssIssueData>[]): Issue<OssIssueData>[] {
    return issues.filter(vuln => {
      switch (vuln.severity.toLowerCase()) {
        case IssueSeverity.Critical:
          return this.configuration.severityFilter.critical;
        case IssueSeverity.High:
          return this.configuration.severityFilter.high;
        case IssueSeverity.Medium:
          return this.configuration.severityFilter.medium;
        case IssueSeverity.Low:
          return this.configuration.severityFilter.low;
        default:
          return true;
      }
    });
  }

  getRunTestMessage = () => messages.treeView.runTest;

  getIssueTitle = (issue: Issue<OssIssueData>) => issue.title;

  getIssueRange = () => undefined;

  getOpenIssueCommand(
    issue: Issue<OssIssueData>,
    _folderPath: string,
    _filePath: string,
    filteredIssues: Issue<OssIssueData>[],
  ): Command {
    return {
      command: SNYK_OPEN_ISSUE_COMMAND,
      title: '',
      arguments: [
        {
          issueType: OpenCommandIssueType.OssVulnerability,
          issue: this.getOssIssueCommandArg(issue, filteredIssues),
        } as OpenIssueCommandArg,
      ],
    };
  }

  getOssIssueCommandArg(vuln: Issue<OssIssueData>, filteredVulns: Issue<OssIssueData>[]): OssIssueCommandArg {
    const matchingIdVulnerabilities = filteredVulns.filter(v => v.id === vuln.id);
    let overviewHtml = '';

    try {
      // TODO: marked.parse does not sanitize the HTML. See: https://marked.js.org/#usage
      overviewHtml = marked.parse(vuln.additionalData.description);
    } catch (error) {
      overviewHtml = '<p>There was a problem rendering the vulnerability overview</p>';
    }

    return {
      ...vuln,
      matchingIdVulnerabilities,
      overviewHtml,
    };
  }
}
