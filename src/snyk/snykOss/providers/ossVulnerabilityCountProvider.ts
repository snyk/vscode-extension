import { CliError } from '../../cli/services/cliService';
import { Language, languageToString } from '../../common/types';
import { ILanguageClientAdapter } from '../../common/vscode/languageClient';
import { ITextDocumentAdapter } from '../../common/vscode/textdocument';
import { InlineValueText, LSPTextDocument } from '../../common/vscode/types';
import { IUriAdapter } from '../../common/vscode/uri';
import { convertIssue, isResultCliError, OssFileResult, OssResultBody } from '../interfaces';
import { OssService } from '../ossService';
import { ImportedModule, ModuleVulnerabilityCount } from '../services/vulnerabilityCount/importedModule';
import { VulnerabilityCountEmitter } from '../services/vulnerabilityCount/vulnerabilityCountEmitter';

export class OssVulnerabilityCountProvider {
  constructor(
    private readonly ossService: OssService,
    private readonly languageClientAdapter: ILanguageClientAdapter,
    private readonly uriAdapter: IUriAdapter,
    private readonly textDocumentAdapter: ITextDocumentAdapter,
  ) {}

  async getVulnerabilityCount(
    fileName: string,
    module: ImportedModule,
    language: Language,
    emitter: VulnerabilityCountEmitter,
  ): Promise<ModuleVulnerabilityCount> {
    let moduleVulnerabilityCount: ModuleVulnerabilityCount = {
      name: module.name,
      fileName: module.fileName,
      line: module.line,
      range: module.loc,
      hasCount: false,
    };

    const processFile = [Language.TypeScript, Language.JavaScript, Language.PJSON, Language.HTML].includes(language);
    if (processFile) {
      const uri = this.uriAdapter.file(fileName).toString();
      const doc: LSPTextDocument = this.textDocumentAdapter.create(uri, languageToString(language), 1, '');

      let firstLine = 0;
      let lastLine = doc.lineCount;
      let firstCharacter = 0;
      let lastCharacter = Number.MAX_SAFE_INTEGER;

      if (module.loc) {
        firstLine = module.loc.start.line - 1;
        lastLine = module.loc.end.line - 1;
        firstCharacter = module.loc.start.column;
        lastCharacter = module.loc.end.column;
      }

      const param = {
        textDocument: { uri: doc.uri },
        range: {
          start: { line: firstLine, character: firstCharacter },
          end: { line: lastLine, character: lastCharacter },
        },
      };

      const inlineValues: InlineValueText[] = await this.languageClientAdapter
        .getLanguageClient()
        .sendRequest('textDocument/inlineValue', param);

      if (inlineValues?.length > 0) {
        moduleVulnerabilityCount = {
          name: module.name,
          version: module.version,
          fileName: module.fileName,
          line: module.line,
          range: module.loc,
          count: inlineValues[0].text,
          hasCount: true,
        };
      }
    }

    emitter?.scanned(moduleVulnerabilityCount);
    return moduleVulnerabilityCount;
  }

  isFilePartOfOssTest(filePath: string, ossFileResult: OssFileResult): boolean {
    if (isResultCliError(ossFileResult)) {
      return false;
    }

    // File is considered to be part of OSS test if it has common root directory between OSS result path and filename path.
    // This is since package.json always lies in the root directory folder of a project.
    return filePath.startsWith(ossFileResult.path);
  }

  public getResultArray = (): ReadonlyArray<OssFileResult> | undefined => {
    if (!this.ossService.result) {
      return undefined;
    }

    const tempResultArray: OssFileResult[] = [];
    const resultCache = new Map<string, OssResultBody>();

    for (const [, value] of this.ossService.result) {
      // value is Error
      if (value instanceof Error) {
        tempResultArray.push(new CliError(value));
      }
      // value is Issue<T>[]
      else {
        for (const issue of value) {
          // try to access list of vulns for the current file
          let res = resultCache.get(issue.filePath);

          // add list of vulns to local cache if not there yet
          if (res === undefined) {
            res = {
              path: issue.filePath,
              vulnerabilities: [],
              projectName: issue.additionalData.projectName,
              displayTargetFile: issue.additionalData.displayTargetFile,
              packageManager: issue.additionalData.packageManager,
            };
            resultCache.set(issue.filePath, res);
          }

          const tempVuln = convertIssue(issue);
          res.vulnerabilities.push(tempVuln);
        }
      }
    }

    // copy cached results to final result array
    resultCache.forEach(value => tempResultArray.push(value));

    return tempResultArray;
  };
}
