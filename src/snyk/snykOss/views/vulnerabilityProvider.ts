import { OpenIssueCommandArg, OpenCommandIssueType } from '../../common/commands/types';
import { SNYK_OPEN_ISSUE_COMMAND } from '../../common/constants/commands';
import { IContextService } from '../../common/services/contextService';
import { IViewManagerService } from '../../common/services/viewManagerService';
import { AnalysisTreeNodeProvder } from '../../common/views/analysisTreeNodeProvider';
import { INodeIcon, NODE_ICONS, TreeNode } from '../../common/views/treeNode';
import { messages } from '../messages/treeView';
import { OssVulnerability } from '../ossResult';
import { OssService } from '../services/ossService';

enum OssSeverity {
  Low = 'low',
  Medium = 'medium',
  High = 'high',
  Critical = 'critical',
}

type ISeverityCounts = {
  [key in OssSeverity]: number;
};

export type OssIssueCommandArg = OssVulnerability & {
  matchingIdVulnerabilities: OssVulnerability[];
};

export class OssVulnerabilityProvider extends AnalysisTreeNodeProvder {
  constructor(
    protected readonly viewManagerService: IViewManagerService,
    protected readonly contextService: IContextService,
    protected readonly ossService: OssService,
  ) {
    super(ossService);
  }

  getRootChildren(): TreeNode[] {
    const nodes: TreeNode[] = [];

    if (!this.contextService.shouldShowAnalysis) return nodes;
    if (this.ossService.isAnalysisRunning) {
      nodes.push(
        new TreeNode({
          text: messages.testRunning,
        }),
      );
      return nodes;
    }

    const ossResult = this.ossService.getResult();
    if (!ossResult) {
      nodes.push(
        new TreeNode({
          text: messages.runTest,
        }),
      );
      return nodes;
    }

    let totalVulnCount = 0;
    const results = Array.isArray(ossResult) ? ossResult : [ossResult];

    for (const fileResult of results) {
      const counts: ISeverityCounts = this.initFileSeverityCounts();
      const vulnerabilityNodes: TreeNode[] = [];

      const fileVulnerabilities = this.getUniqueVulnerabilities(fileResult.vulnerabilities);
      for (const vuln of fileVulnerabilities) {
        counts[vuln.severity]++;
        totalVulnCount++;
        vulnerabilityNodes.push(
          new TreeNode({
            text: `${vuln.packageName}@${vuln.version} - ${vuln.title}`,
            icon: OssVulnerabilityProvider.getSeverityIcon(vuln.severity),
            internal: {
              severity: OssVulnerabilityProvider.getSeverityComparatorIndex(vuln.severity as OssSeverity),
            },
            command: {
              command: SNYK_OPEN_ISSUE_COMMAND,
              title: '',
              arguments: [
                {
                  issueType: OpenCommandIssueType.OssVulnerability,
                  issue: this.getOssIssueCommandArg(vuln, fileResult.vulnerabilities),
                } as OpenIssueCommandArg,
              ],
            },
          }),
        );
      }

      vulnerabilityNodes.sort(this.compareNodes);
      const fileSeverity = OssVulnerabilityProvider.getFileSeverity(counts);

      const fileNode = new TreeNode({
        text: fileResult.displayTargetFile,
        description: this.getIssueDescriptionText(fileResult.projectName, fileVulnerabilities),
        icon: OssVulnerabilityProvider.getSeverityIcon(fileSeverity),
        children: vulnerabilityNodes,
        internal: {
          nIssues: vulnerabilityNodes.length,
          severity: OssVulnerabilityProvider.getSeverityComparatorIndex(fileSeverity),
        },
      });
      nodes.push(fileNode);
    }

    nodes.sort(this.compareNodes);

    nodes.unshift(
      new TreeNode({
        text: this.getIssueFoundText(totalVulnCount),
      }),
      this.getDurationTreeNode(),
    );

    return nodes;
  }

  protected getIssueFoundText(nIssues: number): string {
    switch (nIssues) {
      case 0:
        return messages.noVulnerabilitiesFound;
      case 1:
        return messages.singleVulnerabilityFound;
      default:
        return messages.multipleVulnerabilitiesFound(nIssues);
    }
  }

  protected getIssueDescriptionText(
    dir: string | undefined,
    vulnerabilities: readonly OssVulnerability[],
  ): string | undefined {
    return `${dir} - ${vulnerabilities.length} ${
      vulnerabilities.length === 1 ? messages.vulnerability : messages.vulnerabilities
    }`;
  }

  static getSeverityIcon(severity: OssSeverity | string): INodeIcon {
    return (
      {
        [OssSeverity.Critical]: NODE_ICONS.critical,
        [OssSeverity.High]: NODE_ICONS.high,
        [OssSeverity.Medium]: NODE_ICONS.medium,
        [OssSeverity.Low]: NODE_ICONS.low,
      }[severity] || NODE_ICONS.low
    );
  }

  static getFileSeverity(counts: ISeverityCounts): OssSeverity {
    for (const s of [OssSeverity.Critical, OssSeverity.High, OssSeverity.Medium, OssSeverity.Low]) {
      if (counts[s]) return s;
    }

    return OssSeverity.Low;
  }

  /** Returns severity significance index. The higher, the more significant severity is. */
  static getSeverityComparatorIndex(severity: OssSeverity): number {
    return Object.values(OssSeverity).indexOf(severity);
  }

  onDidChangeTreeData = this.viewManagerService.refreshOssViewEmitter.event;

  private initFileSeverityCounts(): ISeverityCounts {
    return {
      [OssSeverity.Critical]: 0,
      [OssSeverity.High]: 0,
      [OssSeverity.Medium]: 0,
      [OssSeverity.Low]: 0,
    };
  }

  private getUniqueVulnerabilities(vulnerabilities: OssVulnerability[]): OssVulnerability[] {
    return vulnerabilities.filter((val, i, arr) => arr.findIndex(el => el.id === val.id) == i);
  }

  private getOssIssueCommandArg(
    vulnerability: OssVulnerability,
    allVulnerabilities: OssVulnerability[],
  ): OssIssueCommandArg {
    const matchingIdVulnerabilities = allVulnerabilities.filter(v => v.id === vulnerability.id);

    return {
      ...vulnerability,
      matchingIdVulnerabilities: matchingIdVulnerabilities,
    };
  }
}
