import npmValidPackageName from 'validate-npm-package-name';
import { TextDocument } from 'vscode';
import { IConfiguration } from '../../../common/configuration/configuration';
import { ILog } from '../../../common/logger/interfaces';
import { Disposable } from '../../../common/vscode/types';
import { IVSCodeWindow } from '../../../common/vscode/window';
import { IVSCodeWorkspace } from '../../../common/vscode/workspace';
import { HTML_FILE_REGEX, JAVASCRIPT_FILE_REGEX, TYPESCRIPT_FILE_REGEX } from '../../constants/languageRegex';
import nativeModules from '../../constants/nativeModules';
import { VulnerabilityCountEmitter, VulnerabilityCountEvents } from '../../vulnerabilityCountEmitter';
import { OssService } from '../ossService';
import { ImportedModule } from './importedModule';
import { ModuleParserProvider } from './parsers/moduleParserProvider';
import { ModuleVulnerabilityCountProvider } from './vulnerabilityCountProvider';

export enum SupportedLanguage {
  TypeScript,
  JavaScript,
  HTML,
  PJSON,
}

export class OssVulnerabilityCountService {
  protected disposables: Disposable[] = [];

  private emitters = new Map<string, VulnerabilityCountEmitter>();

  constructor(
    private readonly workspace: IVSCodeWorkspace,
    private readonly window: IVSCodeWindow,
    private readonly config: IConfiguration,
    private readonly vulnerabilityCountProvider: ModuleVulnerabilityCountProvider,
    private readonly ossService: OssService,
    private readonly logger: ILog,
  ) {}

  activate(): boolean {
    if (!this.config.isDevelopment) {
      // Do not activate service in production until we have feature flag story.
      return false;
    }

    this.disposables.push(
      this.workspace.onDidChangeTextDocument(ev => {
        if (ev.contentChanges.length) {
          this.processFile(ev.document);
        }
      }),
      this.window.onDidChangeActiveTextEditor(ev => {
        if (ev) {
          this.processFile(ev.document);
        }
      }),
    );

    const activeEditor = this.window.getActiveTextEditor();
    if (activeEditor) {
      this.processFile(activeEditor.document);
    }

    return true;
  }

  dispose(): void {
    while (this.disposables.length) {
      const disposable = this.disposables.pop();
      if (disposable) {
        disposable.dispose();
      }
    }

    for (const emitter of this.emitters.values()) {
      emitter.removeAllListeners();
    }
  }

  processFile(document: TextDocument): boolean {
    if (!document) {
      return false;
    }

    const { fileName, languageId } = document;
    const supportedLanguage = this.getSupportedLanguage(fileName, languageId);
    if (supportedLanguage === null || !this.shouldProcessFile(fileName, supportedLanguage)) {
      return false;
    }

    let emitter = this.emitters.get(fileName);
    if (emitter) {
      emitter.removeAllListeners();
    } else {
      emitter = new VulnerabilityCountEmitter();
      this.emitters.set(fileName, emitter);
    }

    // Todo: implement in package.json parsing in ROAD-294
    // emitter.on('package', createPackageWatcher);

    emitter.on(VulnerabilityCountEvents.Error, e => this.logger.error(`Error counting module vulnerabilities: ${e}`));

    emitter.on(VulnerabilityCountEvents.Start, _packages => {
      // Todo: ROAD-475
      // flushDecorations(fileName, packages);
    });
    emitter.on(VulnerabilityCountEvents.Scanned, _moduleInfo => {
      // Todo: ROAD-475
      // calculated(packageInfo);
    });

    emitter.on(VulnerabilityCountEvents.Done, _modules => {
      // Todo: ROAD-475
      // flushDecorations(fileName, packages, true);
      // refreshDiagnostics(document, diagnostics, packages);
    });

    // Start
    void this.getImportedModules(fileName, document.getText(), supportedLanguage, emitter);
    return true;
  }

  private shouldProcessFile(fileName: string, language: SupportedLanguage): boolean {
    if ([SupportedLanguage.TypeScript, SupportedLanguage.JavaScript].includes(language)) {
      const ossResult = this.ossService.getResultArray();
      if (!ossResult) {
        return false;
      }

      for (const fileResult of ossResult) {
        if (this.vulnerabilityCountProvider.isFilePartOfOssTest(fileName, fileResult)) {
          return true;
        }
      }

      return false;
    }

    return true;
  }

  private getSupportedLanguage(fileName: string, languageId: string): SupportedLanguage | null {
    if (languageId === 'typescript' || languageId === 'typescriptreact' || TYPESCRIPT_FILE_REGEX.test(fileName)) {
      return SupportedLanguage.TypeScript;
    } else if (
      languageId === 'javascript' ||
      languageId === 'javascriptreact' ||
      JAVASCRIPT_FILE_REGEX.test(fileName)
    ) {
      return SupportedLanguage.JavaScript;
    } else if (languageId === 'html' || HTML_FILE_REGEX.test(fileName)) {
      return SupportedLanguage.HTML;
    } else if (languageId === 'json' && fileName.endsWith('package.json')) {
      return SupportedLanguage.PJSON;
    }

    return null;
  }

  private async getImportedModules(
    fileName: string,
    content: string,
    language: SupportedLanguage,
    emitter: VulnerabilityCountEmitter,
  ): Promise<void> {
    try {
      const modules = this.getModules(fileName, content, language).filter(this.isValidModuleName.bind(this));
      emitter.startScanning(modules);

      const promises = modules
        .map(module => this.vulnerabilityCountProvider.getVulnerabilityCount(module, language))
        .map(promise =>
          promise.then(module => {
            emitter.scanned(module);
            return module;
          }),
        );
      const testedModules = await Promise.all(promises);
      emitter.done(testedModules);
    } catch (e) {
      emitter.error(e);
    }
  }

  private isValidModuleName(module: ImportedModule): boolean {
    const moduleName = module.name;
    if (nativeModules.includes(moduleName.toLowerCase())) {
      return false;
    }

    if (moduleName.trim() == '' || /^[.~]/.test(moduleName)) {
      return false;
    }

    if (moduleName.includes('/') && !moduleName.startsWith('@')) {
      const newName = module.name.split('/').shift();
      if (newName) {
        // mutatingâ€¦
        module.name = newName;
      } else {
        return false;
      }
    }

    const valid = npmValidPackageName(module.name);
    if (valid.errors) {
      // invalid package name, so isn't real, so we'll bail
      return false;
    }

    return true;
  }

  private getModules(fileName: string, source: string, language: SupportedLanguage): ImportedModule[] {
    const parser = ModuleParserProvider.getInstance(language);
    if (!parser) {
      return [];
    }

    return parser.getModules(fileName, source, language);
  }
}
