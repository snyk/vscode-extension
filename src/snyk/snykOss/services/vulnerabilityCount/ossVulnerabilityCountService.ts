import { Subscription } from 'rxjs';
import npmValidPackageName from 'validate-npm-package-name';
import { IAnalytics } from '../../../common/analytics/itly';
import { IConfiguration } from '../../../common/configuration/configuration';
import { ILog } from '../../../common/logger/interfaces';
import { ICodeActionKindAdapter } from '../../../common/vscode/codeAction';
import { IVSCodeLanguages } from '../../../common/vscode/languages';
import { Diagnostic, DiagnosticCollection, Disposable, TextDocument } from '../../../common/vscode/types';
import { IVSCodeWindow } from '../../../common/vscode/window';
import { IVSCodeWorkspace } from '../../../common/vscode/workspace';
import { DIAGNOSTICS_OSS_COLLECTION_NAME } from '../../../snykCode/constants/analysis';
import { VulnerabilityCodeActionProvider } from '../../codeActions/vulnerabilityCodeActionProvider';
import {
  HTML,
  HTML_FILE_REGEX,
  JAVASCRIPT,
  JAVASCRIPT_FILE_REGEX,
  JAVASCRIPT_REACT,
  PJSON,
  TYPESCRIPT,
  TYPESCRIPT_FILE_REGEX,
  TYPESCRIPT_REACT,
} from '../../constants/language';
import nativeModules from '../../constants/nativeModules';
import { EditorDecorator } from '../../editor/editorDecorator';
import { messages } from '../../messages/vulnerabilityCount';
import { VulnerabilityCountEmitter, VulnerabilityCountEvents } from '../../vulnerabilityCountEmitter';
import { OssService } from '../ossService';
import { ImportedModule, ModuleVulnerabilityCount, ModuleVulnerabilityCountSeverity } from './importedModule';
import { ModuleParserProvider } from './parsers/moduleParserProvider';
import { ModuleVulnerabilityCountProvider } from './vulnerabilityCountProvider';

export enum SupportedLanguage {
  TypeScript,
  JavaScript,
  HTML,
  PJSON,
}

export class OssVulnerabilityCountService implements Disposable {
  protected disposables: Disposable[] = [];
  protected ossScanFinishedSubscription: Subscription;

  private emitters = new Map<string, VulnerabilityCountEmitter>();
  private diagnostics: DiagnosticCollection | undefined;

  constructor(
    private readonly workspace: IVSCodeWorkspace,
    private readonly window: IVSCodeWindow,
    private readonly languages: IVSCodeLanguages,
    private readonly config: IConfiguration,
    private readonly vulnerabilityCountProvider: ModuleVulnerabilityCountProvider,
    private readonly ossService: OssService,
    private readonly logger: ILog,
    private readonly editorDecorator: EditorDecorator,
    private readonly codeActionKindProvider: ICodeActionKindAdapter,
    private readonly analytics: IAnalytics,
  ) {}

  activate(): boolean {
    if (!this.config.isDevelopment) {
      // Do not activate service in production until we have feature flag story.
      return false;
    }

    this.disposables.push(
      (this.diagnostics = this.languages.createDiagnosticCollection(DIAGNOSTICS_OSS_COLLECTION_NAME)),
      this.workspace.onDidChangeTextDocument(ev => {
        if (ev.contentChanges.length) {
          this.processFile(ev.document);
        }
      }),
      this.window.onDidChangeActiveTextEditor(ev => {
        if (ev) {
          this.processFile(ev.document);
        }
      }),
    );

    // Subscribe to OSS scan finished updates
    this.ossScanFinishedSubscription = this.ossService.scanFinished$.subscribe(() => this.processActiveEditor());

    [JAVASCRIPT, TYPESCRIPT].map(language => {
      const provider = new VulnerabilityCodeActionProvider(
        this.ossService,
        this.vulnerabilityCountProvider,
        this.codeActionKindProvider,
        this.analytics,
      );
      this.disposables.push(
        this.languages.registerCodeActionsProvider(language, provider, {
          providedCodeActionKinds: provider.codeActionKinds,
        }),
      );
    });

    this.processActiveEditor();

    return true;
  }

  processActiveEditor(): void {
    const activeEditor = this.window.getActiveTextEditor();
    if (activeEditor) {
      this.processFile(activeEditor.document);
    }
  }

  dispose(): void {
    while (this.disposables.length) {
      const disposable = this.disposables.pop();
      if (disposable) {
        disposable.dispose();
      }
    }

    for (const emitter of this.emitters.values()) {
      emitter.removeAllListeners();
    }

    this.ossScanFinishedSubscription.unsubscribe();
  }

  processFile(document: TextDocument): boolean {
    if (!document) {
      return false;
    }

    const { fileName, languageId } = document;
    const supportedLanguage = this.getSupportedLanguage(fileName, languageId);
    if (supportedLanguage === null || !this.shouldProcessFile(fileName, supportedLanguage)) {
      return false;
    }

    let emitter = this.emitters.get(fileName);
    if (emitter) {
      emitter.removeAllListeners();
    } else {
      emitter = new VulnerabilityCountEmitter();
      this.emitters.set(fileName, emitter);
    }

    // Todo: implement in package.json parsing in ROAD-294
    // emitter.on('package', createPackageWatcher);

    emitter.on(VulnerabilityCountEvents.Error, e => this.logger.error(`Error counting module vulnerabilities: ${e}`));

    emitter.on(VulnerabilityCountEvents.Start, (modules: ImportedModule[]) => {
      this.editorDecorator.setScanStartDecorations(fileName, modules);
    });
    emitter.on(VulnerabilityCountEvents.Scanned, (vulnerabilityCount: ModuleVulnerabilityCount) => {
      this.editorDecorator.setScannedDecoration(vulnerabilityCount, true);
    });

    emitter.on(VulnerabilityCountEvents.Done, (modules: ModuleVulnerabilityCount[]) => {
      this.editorDecorator.setScanDoneDecorations(fileName, modules);
      this.updateDiagnostics(document, modules);
    });

    // Start
    void this.getImportedModules(fileName, document.getText(), supportedLanguage, emitter);
    return true;
  }

  private updateDiagnostics(document: TextDocument, modules: ModuleVulnerabilityCount[]): void {
    if (!this.diagnostics) {
      return;
    }

    const diagnostics: Diagnostic[] = [];
    for (const module of modules) {
      if (!module.hasCount || !module.range) {
        continue;
      }

      const diagnosticMessage = this.getDiagnosticMessage(module);
      if (!diagnosticMessage.length) {
        continue;
      }

      const range = this.languages.createRange(
        module.range.start.line - 1,
        module.range.start.column,
        module.range.end.line - 1,
        module.range.end.column,
      );

      const diagnostic = this.languages.createDiagnostic(range, diagnosticMessage, 1); // Warning severity
      diagnostics.push({
        ...diagnostic,
        source: DIAGNOSTICS_OSS_COLLECTION_NAME,
        code: module.mostSevereVulnerabilityId,
      });
    }

    this.diagnostics.set(document.uri, diagnostics);
  }

  private shouldProcessFile(fileName: string, language: SupportedLanguage): boolean {
    if ([SupportedLanguage.TypeScript, SupportedLanguage.JavaScript].includes(language)) {
      const ossResult = this.ossService.getResultArray();
      if (!ossResult) {
        return false;
      }

      for (const fileResult of ossResult) {
        if (this.vulnerabilityCountProvider.isFilePartOfOssTest(fileName, fileResult)) {
          return true;
        }
      }

      return false;
    }

    return true;
  }

  private getSupportedLanguage(fileName: string, languageId: string): SupportedLanguage | null {
    if (languageId === TYPESCRIPT || languageId === TYPESCRIPT_REACT || TYPESCRIPT_FILE_REGEX.test(fileName)) {
      return SupportedLanguage.TypeScript;
    } else if (languageId === JAVASCRIPT || languageId === JAVASCRIPT_REACT || JAVASCRIPT_FILE_REGEX.test(fileName)) {
      return SupportedLanguage.JavaScript;
    } else if (languageId === HTML || HTML_FILE_REGEX.test(fileName)) {
      return SupportedLanguage.HTML;
    } else if (languageId === PJSON && fileName.endsWith('package.json')) {
      return SupportedLanguage.PJSON;
    }

    return null;
  }

  private async getImportedModules(
    fileName: string,
    content: string,
    language: SupportedLanguage,
    emitter: VulnerabilityCountEmitter,
  ): Promise<void> {
    try {
      const modules = this.getModules(fileName, content, language).filter(this.isValidModuleName.bind(this));
      emitter.startScanning(modules);

      const promises = modules
        .map(module => this.vulnerabilityCountProvider.getVulnerabilityCount(module, language))
        .map(promise =>
          promise.then(module => {
            emitter.scanned(module);
            return module;
          }),
        );
      const testedModules = await Promise.all(promises);
      emitter.done(testedModules);
    } catch (e) {
      emitter.error(e);
    }
  }

  private isValidModuleName(module: ImportedModule): boolean {
    const moduleName = module.name;
    if (nativeModules.includes(moduleName.toLowerCase())) {
      return false;
    }

    if (moduleName.trim() == '' || /^[.~]/.test(moduleName)) {
      return false;
    }

    if (moduleName.includes('/') && !moduleName.startsWith('@')) {
      const newName = module.name.split('/').shift();
      if (newName) {
        // mutatingâ€¦
        module.name = newName;
      } else {
        return false;
      }
    }

    const valid = npmValidPackageName(module.name);
    if (valid.errors) {
      // invalid package name, so isn't real, so we'll bail
      return false;
    }

    return true;
  }

  private getModules(fileName: string, source: string, language: SupportedLanguage): ImportedModule[] {
    const parser = ModuleParserProvider.getInstance(language);
    if (!parser) {
      return [];
    }

    return parser.getModules(fileName, source, language);
  }

  private getDiagnosticMessage(module: ModuleVulnerabilityCount): string {
    if (!module.count || !module.severityCounts) {
      return '';
    }

    let message = messages.diagnosticMessagePrefix(module);
    message += this.getSeverityCountMessage(
      [
        ModuleVulnerabilityCountSeverity.Critical,
        ModuleVulnerabilityCountSeverity.High,
        ModuleVulnerabilityCountSeverity.Medium,
        ModuleVulnerabilityCountSeverity.Low,
      ],
      module,
    );
    message += module.count > 1 ? ` ${messages.vulnerabilities}.` : ` ${messages.vulnerabilities}.`;
    return message;
  }

  private getSeverityCountMessage(
    severities: ModuleVulnerabilityCountSeverity[],
    module: ModuleVulnerabilityCount,
  ): string {
    if (!module.severityCounts) {
      return '';
    }

    const content: string[] = [];
    for (const severity of severities) {
      if (module.severityCounts[severity] > 0) {
        content.push(`${module.severityCounts[severity]} ${severity}`);
      }
    }

    return content.join(', ');
  }
}
