import _ from 'lodash';
import { Subscription } from 'rxjs';
import { IAnalytics } from '../../../common/analytics/itly';
import { IConfiguration } from '../../../common/configuration/configuration';
import { ILog } from '../../../common/logger/interfaces';
import { getSupportedLanguage, isValidModuleName } from '../../../common/parsing';
import { ModuleParserProvider } from '../../../common/services/moduleParserProvider';
import { Language } from '../../../common/types';
import { IVSCodeLanguages } from '../../../common/vscode/languages';
import {
  DiagnosticCollection,
  Disposable,
  TextDocument,
  TextDocumentChangeEvent,
  TextEditor,
} from '../../../common/vscode/types';
import { IVSCodeWindow } from '../../../common/vscode/window';
import { IVSCodeWorkspace } from '../../../common/vscode/workspace';
import { EditorDecorator } from '../../editor/editorDecorator';
import { OssService } from '../../ossService';
import { OssVulnerabilityCountProvider } from '../../providers/ossVulnerabilityCountProvider';
import { ImportedModule, ModuleVulnerabilityCount } from './importedModule';
import { VulnerabilityCountEmitter, VulnerabilityCountEvents } from './vulnerabilityCountEmitter';

export enum SupportedLanguage {
  TypeScript,
  JavaScript,
  HTML,
  PJSON,
}

export class OssVulnerabilityCountService implements Disposable {
  protected disposables: Disposable[] = [];
  protected ossScanFinishedSubscription: Subscription;

  private fileEmitters = new Map<string, VulnerabilityCountEmitter>();
  private diagnostics: DiagnosticCollection | undefined;

  constructor(
    private readonly workspace: IVSCodeWorkspace,
    private readonly window: IVSCodeWindow,
    private readonly languages: IVSCodeLanguages,
    private readonly vulnerabilityCountProvider: OssVulnerabilityCountProvider,
    private readonly ossService: OssService,
    private readonly logger: ILog,
    private readonly editorDecorator: EditorDecorator,
    private readonly analytics: IAnalytics,
    private readonly configuration: IConfiguration,
  ) {}
  activate(): boolean {
    this.disposables.push(
      this.workspace.onDidChangeTextDocument((ev: TextDocumentChangeEvent) => {
        if (ev?.contentChanges.length) {
          _.debounce(() => this.processFile(ev.document), 500);
        }
      }),
      this.window.onDidChangeActiveTextEditor((ev: TextEditor | undefined) => {
        if (ev) {
          this.processFile(ev.document);
        }
      }),
    );

    // Subscribe to OSS scan finished updates
    this.ossScanFinishedSubscription = this.ossService.newResultAvailable$.subscribe(() => this.processActiveEditor());

    return true;
  }

  processActiveEditor(): void {
    const activeEditor = this.window.getActiveTextEditor();

    if (activeEditor) {
      this.processFile(activeEditor.document);
    }
  }

  dispose(): void {
    while (this.disposables.length) {
      const disposable = this.disposables.pop();
      if (disposable) {
        disposable.dispose();
      }
    }

    for (const emitter of this.fileEmitters.values()) {
      emitter.removeAllListeners();
    }

    this.ossScanFinishedSubscription.unsubscribe();
  }

  processFile(document: TextDocument): boolean {
    if (!document) {
      return false;
    }

    const { fileName, languageId } = document;
    const supportedLanguage = getSupportedLanguage(fileName, languageId);
    if (supportedLanguage === null || !this.shouldProcessFile(fileName, supportedLanguage)) {
      return false;
    }

    let emitter = this.fileEmitters.get(fileName);
    if (emitter) {
      emitter.removeAllListeners();
      this.editorDecorator.resetDecorations(fileName);
    } else {
      emitter = new VulnerabilityCountEmitter();
      this.fileEmitters.set(fileName, emitter);
    }

    emitter.on(VulnerabilityCountEvents.Error, e => {
      this.logger.error(`Error counting module vulnerabilities: ${e}`);
      this.editorDecorator.resetDecorations(fileName);
    });

    emitter.on(VulnerabilityCountEvents.Start, (modules: ImportedModule[]) => {
      this.editorDecorator.setScanStartDecorations(fileName, modules);
    });

    emitter.on(VulnerabilityCountEvents.Scanned, (vulnerabilityCount: ModuleVulnerabilityCount) => {
      this.editorDecorator.setScannedDecoration(vulnerabilityCount, true);
    });

    emitter.on(VulnerabilityCountEvents.Done, (modules: ModuleVulnerabilityCount[]) => {
      this.editorDecorator.setScanDoneDecorations(fileName, modules);
    });

    // Start
    void this.getImportedModules(fileName, document.getText(), supportedLanguage, emitter);
    return true;
  }

  private shouldProcessFile(fileName: string, language: Language): boolean {
    if ([Language.TypeScript, Language.JavaScript, Language.PJSON].includes(language)) {
      const ossResult = this.vulnerabilityCountProvider.getResultArray();
      if (!ossResult) {
        return false;
      }

      for (const fileResult of ossResult) {
        if (this.vulnerabilityCountProvider.isFilePartOfOssTest(fileName, fileResult)) {
          return true;
        }
      }

      return false;
    }

    return true;
  }

  private async getImportedModules(
    fileName: string,
    content: string,
    language: Language,
    emitter: VulnerabilityCountEmitter,
  ): Promise<void> {
    try {
      const modules = this.getModules(fileName, content, language).filter(isValidModuleName);
      emitter.startScanning(modules);

      const vulnerabilityCountPromises = modules.map(module =>
        this.vulnerabilityCountProvider.getVulnerabilityCount(fileName, module, language, emitter),
      );

      const vulnerabilityCount = await Promise.all(vulnerabilityCountPromises);

      emitter.done(vulnerabilityCount);
    } catch (e) {
      emitter.error(e);
    }
  }

  private getModules(fileName: string, source: string, language: Language): ImportedModule[] {
    const parser = ModuleParserProvider.getInstance(language, this.logger, this.configuration);
    if (!parser) {
      return [];
    }

    return parser.getModules(fileName, source, language);
  }
}
