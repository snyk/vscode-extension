import { Subscription } from 'rxjs';
import { IConfiguration } from '../../../common/configuration/configuration';
import { ILog } from '../../../common/logger/interfaces';
import { getSupportedLanguage, isValidModuleName } from '../../../common/parsing';
import { ModuleParserProvider } from '../../../common/services/moduleParserProvider';
import { Language } from '../../../common/types';
import { IVSCodeLanguages } from '../../../common/vscode/languages';
import {
  Diagnostic,
  DiagnosticCollection,
  Disposable,
  TextDocument,
  TextDocumentChangeEvent,
  TextEditor,
} from '../../../common/vscode/types';
import { IVSCodeWindow } from '../../../common/vscode/window';
import { IVSCodeWorkspace } from '../../../common/vscode/workspace';
import { DIAGNOSTICS_OSS_COLLECTION_NAME } from '../../../snykCode/constants/analysis';
import { EditorDecorator } from '../../editor/editorDecorator';
import { OssService } from '../../ossService';
import { OssVulnerabilityCountProvider } from '../../providers/ossVulnerabilityCountProvider';
import { ImportedModule, ModuleVulnerabilityCount, ModuleVulnerabilityCountSeverity } from './importedModule';
import { VulnerabilityCountEmitter, VulnerabilityCountEvents } from './vulnerabilityCountEmitter';

export class OssVulnerabilityCountService implements Disposable {
  protected disposables: Disposable[] = [];
  protected ossScanFinishedSubscription: Subscription;

  private fileEmitters = new Map<string, VulnerabilityCountEmitter>();
  private diagnostics: DiagnosticCollection | undefined;

  constructor(
    private readonly workspace: IVSCodeWorkspace,
    private readonly window: IVSCodeWindow,
    private readonly languages: IVSCodeLanguages,
    private readonly vulnerabilityCountProvider: OssVulnerabilityCountProvider,
    private readonly ossService: OssService,
    private readonly logger: ILog,
    private readonly editorDecorator: EditorDecorator,
    private readonly configuration: IConfiguration,
  ) {}
  activate(): boolean {
    this.disposables.push(
      (this.diagnostics = this.languages.createDiagnosticCollection(DIAGNOSTICS_OSS_COLLECTION_NAME)),
      this.workspace.onDidChangeTextDocument((ev: TextDocumentChangeEvent) => {
        if (ev?.contentChanges.length) {
          // TODO: this feature is buggy if implemented; reset decorations instead as a compromise
          // this.processFile(ev.document);
          this.editorDecorator.resetDecorations(ev.document.fileName);
        }
      }),
      this.window.onDidChangeActiveTextEditor((ev: TextEditor | undefined) => {
        if (ev) {
          this.processFile(ev.document);
        }
      }),
    );

    // Subscribe to OSS scan finished updates
    this.ossScanFinishedSubscription = this.ossService.newResultAvailable$.subscribe(() => this.processActiveEditor());

    return true;
  }

  processActiveEditor(): void {
    const activeEditor = this.window.getActiveTextEditor();

    if (activeEditor) {
      this.processFile(activeEditor.document);
    }
  }

  dispose(): void {
    while (this.disposables.length) {
      const disposable = this.disposables.pop();
      if (disposable) {
        disposable.dispose();
      }
    }

    for (const emitter of this.fileEmitters.values()) {
      emitter.removeAllListeners();
    }

    this.ossScanFinishedSubscription.unsubscribe();
  }

  processFile(document: TextDocument): boolean {
    if (!document) {
      return false;
    }

    const { fileName, languageId } = document;
    const supportedLanguage = getSupportedLanguage(fileName, languageId);
    if (supportedLanguage === null || !this.shouldProcessFile(fileName, supportedLanguage)) {
      return false;
    }

    let emitter = this.fileEmitters.get(fileName);
    if (emitter) {
      emitter.removeAllListeners();
      this.editorDecorator.resetDecorations(fileName);
    } else {
      emitter = new VulnerabilityCountEmitter();
      this.fileEmitters.set(fileName, emitter);
    }

    emitter.on(VulnerabilityCountEvents.Error, e => {
      this.logger.error(`Error counting module issues: ${e}`);
      this.editorDecorator.resetDecorations(fileName);
    });

    emitter.on(VulnerabilityCountEvents.Start, (modules: ImportedModule[]) => {
      this.editorDecorator.setScanStartDecorations(fileName, modules);
    });

    emitter.on(VulnerabilityCountEvents.Scanned, (vulnerabilityCount: ModuleVulnerabilityCount) => {
      this.editorDecorator.setScannedDecoration(vulnerabilityCount, true);
    });

    emitter.on(VulnerabilityCountEvents.Done, (modules: ModuleVulnerabilityCount[]) => {
      this.editorDecorator.setScanDoneDecorations(fileName, modules);
      // TODO: delete this and related code if we move HTML diagnostics to Language Server
      // Update diagnostics only for HTML files; for other files, diagnostics are provided by Language Server
      if (getSupportedLanguage(fileName, languageId) === Language.HTML) {
        this.updateDiagnostics(document, modules);
      }
    });

    // Start
    void this.getImportedModules(fileName, document.getText(), supportedLanguage, emitter);
    return true;
  }

  private updateDiagnostics(document: TextDocument, modules: ModuleVulnerabilityCount[]): void {
    if (!this.diagnostics) {
      return;
    }

    const diagnostics: Diagnostic[] = [];
    for (const module of modules) {
      if (!module.hasCount || !module.range) {
        continue;
      }

      const diagnosticMessage = this.getDiagnosticMessage(module);
      if (!diagnosticMessage.length) {
        continue;
      }

      const range = this.languages.createRange(
        module.range.start.line - 1,
        module.range.start.column,
        module.range.end.line - 1,
        module.range.end.column,
      );

      const diagnostic = this.languages.createDiagnostic(range, diagnosticMessage, 1); // Warning severity
      diagnostics.push({
        ...diagnostic,
        source: DIAGNOSTICS_OSS_COLLECTION_NAME,
        code: module.mostSevereVulnerabilityId,
      });
    }

    this.diagnostics.set(document.uri, diagnostics);
  }

  private shouldProcessFile(fileName: string, language: Language): boolean {
    if ([Language.TypeScript, Language.JavaScript, Language.PJSON].includes(language)) {
      const ossResult = this.vulnerabilityCountProvider.getResultArray();
      if (!ossResult) {
        return false;
      }

      for (const fileResult of ossResult) {
        if (this.vulnerabilityCountProvider.isFilePartOfOssTest(fileName, fileResult)) {
          return true;
        }
      }

      return false;
    }

    return true;
  }

  private async getImportedModules(
    fileName: string,
    content: string,
    language: Language,
    emitter: VulnerabilityCountEmitter,
  ): Promise<void> {
    try {
      const modules = this.getModules(fileName, content, language).filter(isValidModuleName);
      emitter.startScanning(modules);

      const vulnerabilityCountPromises = modules.map(module =>
        this.vulnerabilityCountProvider.getVulnerabilityCount(fileName, module, language, emitter),
      );

      const vulnerabilityCount = await Promise.all(vulnerabilityCountPromises);

      emitter.done(vulnerabilityCount);
    } catch (e) {
      emitter.error(e);
    }
  }

  private getModules(fileName: string, source: string, language: Language): ImportedModule[] {
    const parser = ModuleParserProvider.getInstance(language, this.logger, this.configuration);
    if (!parser) {
      return [];
    }

    return parser.getModules(fileName, source, language);
  }

  private getDiagnosticMessage(module: ModuleVulnerabilityCount): string {
    if (!module.count) {
      return '';
    }

    let message = `Dependency ${module.name}${module.version ? `@${module.version}` : ''} has `;
    message += this.getSeverityCountMessage(
      [
        ModuleVulnerabilityCountSeverity.Critical,
        ModuleVulnerabilityCountSeverity.High,
        ModuleVulnerabilityCountSeverity.Medium,
        ModuleVulnerabilityCountSeverity.Low,
      ],
      module,
    );

    return message;
  }

  private getSeverityCountMessage(
    severities: ModuleVulnerabilityCountSeverity[],
    module: ModuleVulnerabilityCount,
  ): string {
    if (!module.severityCounts) {
      return module.count ? module.count : '';
    }

    const content: string[] = [];
    for (const severity of severities) {
      if (module.severityCounts[severity] > 0) {
        content.push(`${module.severityCounts[severity]} ${severity}`);
      }
    }

    return content.join(', ');
  }
}
