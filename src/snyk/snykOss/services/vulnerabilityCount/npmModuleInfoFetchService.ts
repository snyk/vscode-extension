import finder from 'find-package-json';
import _ from 'lodash';
import { dirname, join } from 'path';
import { IConfiguration } from '../../../common/configuration/configuration';
import { ILog } from '../../../common/logger/interfaces';
import { npmRegistryApi } from '../../api/npmRegistryApi';
import { npmTestApi } from '../../api/npmTestApi';
import { ImportedModule, TestedImportedModule } from './importedModule';

export type NpmRegistryPackage = {
  name: string;
  version: string;
};

export type NpmTestApiResult = {
  resultTitle: string;
  totalVulns: number;
};

class DebounceError extends Error {}

/**
 * Responsible for caching & fetching npm module info
 */
export class NpmModuleInfoFetchService {
  private readonly debounceIntervalInMs = 2000;

  private debouncedPromises: Record<string, _.DebouncedFunc<(...args: unknown[]) => Promise<NpmTestApiResult>>> = {};

  private npmPackageCache = new Map<string, NpmRegistryPackage>();
  private projectCache = new Map<string, string>();
  private vulnerabilityCache = new Map<string, Promise<NpmTestApiResult> | NpmTestApiResult>();

  constructor(private readonly config: IConfiguration, private readonly logger: ILog) {}

  async getModuleVulnerabilityInfo(module: ImportedModule): Promise<TestedImportedModule> {
    const key = await this.getVulnerabilityCacheKey(module);
    if (!key) {
      return { ...module, tested: false };
    }

    const testedModulePromise = this.vulnerabilityCache.get(key);

    if (testedModulePromise === undefined || testedModulePromise instanceof Promise) {
      try {
        const testedModule = await (testedModulePromise || this.lookupVulnerabilities(key, module.string));
        this.vulnerabilityCache.set(key, testedModule);
      } catch (e) {
        this.logger.error(`Failed to lookup vulnerabilities for ${key}. ${e}`);
        this.vulnerabilityCache.delete(key);

        if (e instanceof DebounceError) {
          this.logger.error(`Debounce error has occurred when looking up vulnerabilities. ${e}`);
          throw e;
        } else {
          const result = await this.vulnerabilityCache.get(key);
          if (result) {
            return { ...module, vulnerabilityCount: result.totalVulns, tested: true };
          }

          throw e;
        }
      }
    }

    const result = await this.vulnerabilityCache.get(key);
    if (!result) {
      throw new Error(`Vulnerability result isn't available for ${key} due to missing cache entry.`);
    }

    return { ...module, vulnerabilityCount: result.totalVulns, tested: true };
  }

  private async getVulnerabilityCacheKey(module: ImportedModule): Promise<string | undefined> {
    try {
      const npmPackage = await this.getNpmRegistryPackage(module);
      return `${npmPackage.name}@${npmPackage.version}`;
    } catch (e) {
      this.logger.error(e);
      return undefined;
    }
  }

  private async getNpmRegistryPackage(module: ImportedModule) {
    let npmPackage: NpmRegistryPackage;
    if (module.string) {
      npmPackage = this.npmPackageCache.get(module.string) || (await this.fetchNpmRegistryPackage(module));
      this.npmPackageCache.set(module.string, npmPackage);
    } else {
      npmPackage = await this.fetchNpmRegistryPackage(module);
      this.npmPackageCache.set(module.string, npmPackage);
    }

    return npmPackage;
  }

  private async fetchNpmRegistryPackage(module: ImportedModule): Promise<NpmRegistryPackage> {
    if (module.version && module.name) {
      return { name: module.name, version: module.version };
    }

    let dir = this.projectCache.get(module.fileName);

    if (!dir) {
      const filename = finder(module.fileName).next().filename;
      if (filename) {
        dir = dirname(filename);
        this.projectCache.set(module.fileName, dir);
      } else {
        throw new Error('Cannot find "package.json" to determine module key.');
      }
    }

    const name = module.name;

    const f = finder(join(dir, 'node_modules', name));
    const moduleInfo = f.next().value;

    // if the package doesn't start with the package name we were looking for
    // then it means it's not locally installed, so let's get the version from the
    // npm registry
    if (!moduleInfo || !moduleInfo.name || !moduleInfo.name.toLowerCase().startsWith(name)) {
      try {
        const { data } = await npmRegistryApi.get<NpmRegistryPackage>(`${name}/latest`);

        return { name, version: data.version };
      } catch (err) {
        return {
          name,
          version: 'latest',
        };
      }
    }

    return { name: moduleInfo.name, version: moduleInfo.version ?? 'latest' };
  }

  private lookupVulnerabilities(vulnerabilityKey: string, npmPackageCacheKey: string): Promise<NpmTestApiResult> {
    const npmPackage = this.npmPackageCache.get(npmPackageCacheKey);
    if (!npmPackage) {
      throw new Error('Npm package is not in cache for some reason.');
    }

    return this.debouncePromise(vulnerabilityKey, this.test.bind(this), npmPackage);
  }

  private async test(npmPackage: NpmRegistryPackage): Promise<NpmTestApiResult> {
    const utm = `utm_medium=${this.config.source}&utm_source=${this.config.source}&utm_campaign=${this.config.source}`;

    const result = await npmTestApi.get<NpmTestApiResult>(
      `/npm/${npmPackage.name}/${npmPackage.version}?${utm}&type=json`,
    );

    return result.data;
  }

  private async debouncePromise(
    name: string,
    fn: (...args: unknown[]) => Promise<NpmTestApiResult>,
    ...args: unknown[]
  ): Promise<NpmTestApiResult> {
    if (!this.debouncedPromises[name])
      this.debouncedPromises[name] = _.debounce(
        async (...args: unknown[]): Promise<NpmTestApiResult> => {
          try {
            return await fn(...args);
          } catch (error) {
            throw new DebounceError(error);
          }
        },
        this.debounceIntervalInMs,
        { leading: true, trailing: false },
      );

    return this.debouncedPromises[name](...args) as Promise<NpmTestApiResult>;
  }
}
