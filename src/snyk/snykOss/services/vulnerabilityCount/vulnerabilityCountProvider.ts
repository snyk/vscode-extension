import { Language } from '../../../common/types';
import { isResultCliError, OssFileResult, OssResultBody, OssVulnerability } from '../../ossResult';
import { OssService } from '../ossService';
import { ImportedModule, ModuleVulnerabilityCount, SeverityCounts, TestedImportedModule } from './importedModule';
import { NpmModuleInfoFetchService } from './npmModuleInfoFetchService';

export class ModuleVulnerabilityCountProvider {
  constructor(
    private readonly ossService: OssService,
    private readonly npmModuleInfoFetchService: NpmModuleInfoFetchService,
  ) {}

  async getVulnerabilityCount(module: ImportedModule, language: Language): Promise<ModuleVulnerabilityCount> {
    const notCalculated = {
      name: module.name,
      fileName: module.fileName,
      line: null,
      range: null,
      hasCount: false,
    };

    if ([Language.TypeScript, Language.JavaScript, Language.PJSON].includes(language)) {
      const ossResult = this.ossService.getResultArray();
      if (!ossResult) {
        return notCalculated;
      }

      return this.mapOssResult(module, ossResult);
    } else if (language == Language.HTML) {
      const testedModuleInfo = await this.npmModuleInfoFetchService.getModuleVulnerabilityInfo(module);
      return this.mapTestedImportedModule(testedModuleInfo);
    }

    return notCalculated;
  }

  isFilePartOfOssTest(filePath: string, ossFileResult: OssFileResult): boolean {
    if (isResultCliError(ossFileResult)) {
      return false;
    }

    // File is considered to be part of OSS test if it has common root directory between OSS result path and filename path.
    // This is since package.json always lies in the root directory folder of a project.
    if (filePath.startsWith(ossFileResult.path)) {
      return true;
    }

    return false;
  }

  private mapTestedImportedModule(module: TestedImportedModule): ModuleVulnerabilityCount {
    return {
      name: module.name,
      version: module.version,
      fileName: module.fileName,
      line: module.line,
      range: module.loc,
      count: module.vulnerabilityCount,
      hasCount: module.tested,
    };
  }

  private mapOssResult(module: ImportedModule, ossResult: ReadonlyArray<OssFileResult>): ModuleVulnerabilityCount {
    const notCalculated = {
      name: module.name,
      fileName: module.fileName,
      line: null,
      hasCount: false,
      range: null,
    };

    for (const fileResult of ossResult) {
      if (!this.isFilePartOfOssTest(module.fileName, fileResult)) {
        continue;
      }

      const vulnerabilities = this.ossService.getUniqueVulnerabilities((fileResult as OssResultBody).vulnerabilities);

      // Sum up all vulnerabilities detected in first-level dependencies by OSS matching the imported module name.
      // Ideally we want to use the same mechanism as NPM for determining the version used within users code. For now we stick with direct-vulnerability surfacing only.
      const directVulnerabilities = vulnerabilities
        .filter(v => v.name === module.name)
        .filter(v => v.from.length == 2 && v.from[1].startsWith(module.name));
      const vulnerabilityCount = directVulnerabilities.length;

      // NPM allows declaration of the same direct dependency with multiple versions of it (e.g. {"dependencies": "webpack": "^4.44.1", "webpack": "^4.44.2",}). Thus, we should account for vulnerabilities that can be in different versions of the same package.
      const hasSingleVersionVulnerability = directVulnerabilities.every(
        vuln => vuln.version == directVulnerabilities[0].version,
      );

      let moduleVersion;
      if (directVulnerabilities.length && hasSingleVersionVulnerability) {
        moduleVersion = directVulnerabilities[0].version;
      }

      const severityCounts = this.getSeverityCounts(directVulnerabilities);
      const mostSevereVulnerability = this.getMostSevereVulnerability(directVulnerabilities);

      return {
        name: module.name,
        version: moduleVersion,
        fileName: module.fileName,
        count: vulnerabilityCount,
        line: module.line,
        range: module.loc,
        hasCount: vulnerabilityCount > 0,
        severityCounts,
        mostSevereVulnerabilityId: mostSevereVulnerability?.id,
      };
    }

    return notCalculated;
  }

  private getSeverityCounts(directVulnerabilities: OssVulnerability[]): SeverityCounts {
    return directVulnerabilities
      .map(v => v.severity)
      .reduce(
        (arr, severity) => ({ ...arr, [severity]: directVulnerabilities.filter(v => v.severity == severity).length }),
        {} as SeverityCounts,
      );
  }

  private getMostSevereVulnerability(vulnerabilities: OssVulnerability[]): OssVulnerability | null {
    return vulnerabilities.sort((a, b) => {
      if (!a.cvssScore && !b.cvssScore) return 0;
      if (!a.cvssScore) return 1;
      if (!b.cvssScore) return -1;

      const cvssScore1 = parseFloat(a.cvssScore);
      const cvssScore2 = parseFloat(b.cvssScore);
      if (cvssScore1 > cvssScore2) {
        return -1;
      } else if (cvssScore1 < cvssScore2) {
        return 1;
      }

      return 0;
    })?.[0];
  }
}
