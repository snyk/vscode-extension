import { Language } from '../../../common/types';
import { ILanguageClientAdapter } from '../../../common/vscode/languageClient';
import { ITextDocumentAdapter } from '../../../common/vscode/textdocument';
import { InlineValueText, LSPTextDocument } from '../../../common/vscode/types';
import { IUriAdapter } from '../../../common/vscode/uri';
import { OssFileResult, OssResultBody, OssVulnerability, isResultCliError } from '../../ossResult';
import { OssService } from '../ossService';
import { ImportedModule, ModuleVulnerabilityCount, SeverityCounts } from './importedModule';

export class ModuleVulnerabilityCountProvider {
  constructor(
    private readonly ossService: OssService,
    private readonly lca: ILanguageClientAdapter,
    private readonly uriAdapter: IUriAdapter,
    private readonly textDocumentAdapter: ITextDocumentAdapter,
  ) {}

  async getVulnerabilityCount(
    fileName: string,
    module: ImportedModule,
    language: Language,
  ): Promise<ModuleVulnerabilityCount> {
    const notCalculated = {
      name: module.name,
      fileName: module.fileName,
      line: null,
      range: null,
      hasCount: false,
    };

    if ([Language.TypeScript, Language.JavaScript, Language.PJSON].includes(language)) {
      // TODO use LS when OSS is moved to LS
      const ossResult = this.ossService.getResultArray();
      if (!ossResult) {
        return notCalculated;
      }

      return this.mapOssResult(module, ossResult);
    } else if (language == Language.HTML && module.loc) {
      const uri = this.uriAdapter.file(fileName).toString();
      const doc: LSPTextDocument = this.textDocumentAdapter.create(uri, 'HTML', 1, '');
      const line = module.loc.start.line - 1;
      const param = {
        textDocument: { uri: doc.uri },
        range: {
          start: { line: line, character: module.loc.start.column },
          end: { line: line, character: module.loc.end.column },
        },
      };
      const inlineValues: InlineValueText[] = await this.lca
        .getLanguageClient()
        .sendRequest('textDocument/inlineValue', param);

      if (inlineValues.length > 0) {
        return {
          name: module.name,
          version: module.version,
          fileName: module.fileName,
          line: module.line,
          range: module.loc,
          count: inlineValues[0].text,
          hasCount: true,
        } as ModuleVulnerabilityCount;
      }
    }

    return notCalculated;
  }

  isFilePartOfOssTest(filePath: string, ossFileResult: OssFileResult): boolean {
    if (isResultCliError(ossFileResult)) {
      return false;
    }

    // File is considered to be part of OSS test if it has common root directory between OSS result path and filename path.
    // This is since package.json always lies in the root directory folder of a project.
    return filePath.startsWith(ossFileResult.path);
  }

  private mapOssResult(module: ImportedModule, ossResult: ReadonlyArray<OssFileResult>): ModuleVulnerabilityCount {
    const notCalculated = {
      name: module.name,
      fileName: module.fileName,
      line: null,
      hasCount: false,
      range: null,
    };

    for (const fileResult of ossResult) {
      if (!this.isFilePartOfOssTest(module.fileName, fileResult)) {
        continue;
      }

      const vulnerabilities = this.ossService.getUniqueVulnerabilities((fileResult as OssResultBody).vulnerabilities);

      // Sum up all vulnerabilities detected in first-level dependencies by OSS matching the imported module name.
      // Ideally we want to use the same mechanism as NPM for determining the version used within users code. For now we stick with direct-vulnerability surfacing only.
      const directVulnerabilities = vulnerabilities
        .filter(v => v.name === module.name)
        .filter(v => v.from.length == 2 && v.from[1].startsWith(module.name));
      const vulnerabilityCount = directVulnerabilities.length;

      // NPM allows declaration of the same direct dependency with multiple versions of it (e.g. {"dependencies": "webpack": "^4.44.1", "webpack": "^4.44.2",}). Thus, we should account for vulnerabilities that can be in different versions of the same package.
      const hasSingleVersionVulnerability = directVulnerabilities.every(
        vuln => vuln.version == directVulnerabilities[0].version,
      );

      let moduleVersion;
      if (directVulnerabilities.length && hasSingleVersionVulnerability) {
        moduleVersion = directVulnerabilities[0].version;
      }

      const severityCounts = this.getSeverityCounts(directVulnerabilities);
      const mostSevereVulnerability = this.getMostSevereVulnerability(directVulnerabilities);

      return {
        name: module.name,
        version: moduleVersion,
        fileName: module.fileName,
        count: `${vulnerabilityCount}`,
        line: module.line,
        range: module.loc,
        hasCount: vulnerabilityCount > 0,
        severityCounts,
        mostSevereVulnerabilityId: mostSevereVulnerability?.id,
      };
    }

    return notCalculated;
  }

  private getSeverityCounts(directVulnerabilities: OssVulnerability[]): SeverityCounts {
    return directVulnerabilities
      .map(v => v.severity)
      .reduce(
        (arr, severity) => ({
          ...arr,
          [severity]: directVulnerabilities.filter(v => v.severity == severity).length,
        }),
        {} as SeverityCounts,
      );
  }

  private getMostSevereVulnerability(vulnerabilities: OssVulnerability[]): OssVulnerability | null {
    return vulnerabilities.sort((a, b) => {
      if (!a.cvssScore && !b.cvssScore) return 0;
      if (!a.cvssScore) return 1;
      if (!b.cvssScore) return -1;

      const cvssScore1 = parseFloat(a.cvssScore);
      const cvssScore2 = parseFloat(b.cvssScore);
      if (cvssScore1 > cvssScore2) {
        return -1;
      } else if (cvssScore1 < cvssScore2) {
        return 1;
      }

      return 0;
    })?.[0];
  }
}
