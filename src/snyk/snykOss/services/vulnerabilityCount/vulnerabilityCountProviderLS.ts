import { CliError } from '../../../cli/services/cliService';
import { Language } from '../../../common/types';
import { ILanguageClientAdapter } from '../../../common/vscode/languageClient';
import { ITextDocumentAdapter } from '../../../common/vscode/textdocument';
import { InlineValueText, LSPTextDocument } from '../../../common/vscode/types';
import { IUriAdapter } from '../../../common/vscode/uri';
import { OssFileResult, OssResultBody, OssSeverity, OssVulnerability, isResultCliError } from '../../ossResult';
import { OssServiceLanguageServer } from '../../ossServiceLanguageServer';
import { ImportedModule, ModuleVulnerabilityCount, SeverityCounts } from './importedModule';

export class ModuleVulnerabilityCountProviderLS {
  constructor(
    private readonly ossService: OssServiceLanguageServer,
    private readonly lca: ILanguageClientAdapter,
    private readonly uriAdapter: IUriAdapter,
    private readonly textDocumentAdapter: ITextDocumentAdapter,
  ) {}

  async getVulnerabilityCount(
    fileName: string,
    module: ImportedModule,
    language: Language,
  ): Promise<ModuleVulnerabilityCount> {
    const notCalculated = {
      name: module.name,
      fileName: module.fileName,
      line: null,
      range: null,
      hasCount: false,
    };

    if ([Language.TypeScript, Language.JavaScript, Language.PJSON].includes(language)) {
      const ossResult = this.getResultArray();
      if (!ossResult) {
        return notCalculated;
      }

      return this.mapOssResult(module, ossResult);
    } else if (language == Language.HTML && module.loc) {
      const uri = this.uriAdapter.file(fileName).toString();
      const doc: LSPTextDocument = this.textDocumentAdapter.create(uri, 'HTML', 1, '');
      const line = module.loc.start.line - 1;
      const param = {
        textDocument: { uri: doc.uri },
        range: {
          start: { line: line, character: module.loc.start.column },
          end: { line: line, character: module.loc.end.column },
        },
      };
      const inlineValues: InlineValueText[] = await this.lca
        .getLanguageClient()
        .sendRequest('textDocument/inlineValue', param);

      if (inlineValues.length > 0) {
        return {
          name: module.name,
          version: module.version,
          fileName: module.fileName,
          line: module.line,
          range: module.loc,
          count: inlineValues[0].text,
          hasCount: true,
        } as ModuleVulnerabilityCount;
      }
    }

    return notCalculated;
  }

  isFilePartOfOssTest(filePath: string, ossFileResult: OssFileResult): boolean {
    if (isResultCliError(ossFileResult)) {
      return false;
    }

    // File is considered to be part of OSS test if it has common root directory between OSS result path and filename path.
    // This is since package.json always lies in the root directory folder of a project.
    return filePath.startsWith(ossFileResult.path);
  }

  private mapOssResult(module: ImportedModule, ossResult: ReadonlyArray<OssFileResult>): ModuleVulnerabilityCount {
    const notCalculated = {
      name: module.name,
      fileName: module.fileName,
      line: null,
      hasCount: false,
      range: null,
    };

    for (const fileResult of ossResult) {
      if (!this.isFilePartOfOssTest(module.fileName, fileResult)) {
        continue;
      }

      const vulnerabilities = this.getUniqueVulnerabilities((fileResult as OssResultBody).vulnerabilities);

      // Sum up all vulnerabilities detected in first-level dependencies by OSS matching the imported module name.
      // Ideally we want to use the same mechanism as NPM for determining the version used within users code. For now we stick with direct-vulnerability surfacing only.
      const directVulnerabilities = vulnerabilities
        .filter(v => v.name === module.name)
        .filter(v => v.from.length == 2 && v.from[1].startsWith(module.name));
      const vulnerabilityCount = directVulnerabilities.length;

      // NPM allows declaration of the same direct dependency with multiple versions of it (e.g. {"dependencies": "webpack": "^4.44.1", "webpack": "^4.44.2",}). Thus, we should account for vulnerabilities that can be in different versions of the same package.
      const hasSingleVersionVulnerability = directVulnerabilities.every(
        vuln => vuln.version == directVulnerabilities[0].version,
      );

      let moduleVersion;
      if (directVulnerabilities.length && hasSingleVersionVulnerability) {
        moduleVersion = directVulnerabilities[0].version;
      }

      const severityCounts = this.getSeverityCounts(directVulnerabilities);
      const mostSevereVulnerability = this.getMostSevereVulnerability(directVulnerabilities);

      return {
        name: module.name,
        version: moduleVersion,
        fileName: module.fileName,
        count: `${vulnerabilityCount}`,
        line: module.line,
        range: module.loc,
        hasCount: vulnerabilityCount > 0,
        severityCounts,
        mostSevereVulnerabilityId: mostSevereVulnerability?.id,
      };
    }

    return notCalculated;
  }

  private getSeverityCounts(directVulnerabilities: OssVulnerability[]): SeverityCounts {
    return directVulnerabilities
      .map(v => v.severity)
      .reduce(
        (arr, severity) => ({
          ...arr,
          [severity]: directVulnerabilities.filter(v => v.severity == severity).length,
        }),
        {} as SeverityCounts,
      );
  }

  private getMostSevereVulnerability(vulnerabilities: OssVulnerability[]): OssVulnerability | null {
    return vulnerabilities.sort((a, b) => {
      if (!a.cvssScore && !b.cvssScore) return 0;
      if (!a.cvssScore) return 1;
      if (!b.cvssScore) return -1;

      const cvssScore1 = parseFloat(a.cvssScore);
      const cvssScore2 = parseFloat(b.cvssScore);
      if (cvssScore1 > cvssScore2) {
        return -1;
      } else if (cvssScore1 < cvssScore2) {
        return 1;
      }

      return 0;
    })?.[0];
  }

  public getResultArray = (): ReadonlyArray<OssFileResult> | undefined => {
    if (!this.ossService.result) {
      return undefined;
    }

    let tempResultArray: OssFileResult[] = [];
    let resultCache = new Map<string, OssResultBody>();

    for (const [, value] of this.ossService.result) {
      // value is Error
      if (value instanceof Error) {
        tempResultArray.push(new CliError(value as Error));
      }
      // value is Issue<T>[]
      else {
        for (const issue of value) {
          // try to access list of vulns for the current file
          let res = resultCache.get(issue.filePath);

          // add list of vulns to local cache if not there yet
          if (res === undefined) {
            res = {
              path: issue.filePath,
              vulnerabilities: [],
              projectName: issue.additionalData.projectName,
              displayTargetFile: issue.additionalData.displayTargetFile,
              packageManager: issue.additionalData.packageManager,
            };
            resultCache.set(issue.filePath, res);
          }

          let tempVuln: OssVulnerability = {
            id: issue.id,
            license: issue.additionalData.license,
            identifiers: issue.additionalData.identifiers,
            title: issue.title,
            description: issue.additionalData.description,
            language: issue.additionalData.language,
            packageManager: issue.additionalData.packageManager,
            packageName: issue.additionalData.packageName,
            severity: issue.severity as unknown as OssSeverity,
            name: issue.additionalData.name,
            version: issue.additionalData.version,
            exploit: issue.additionalData.exploit,

            CVSSv3: issue.additionalData.CVSSv3,
            cvssScore: issue.additionalData.cvssScore,

            fixedIn: issue.additionalData.fixedIn,
            from: issue.additionalData.from,
            upgradePath: issue.additionalData.upgradePath,
            isPatchable: issue.additionalData.isPatchable,
            isUpgradable: issue.additionalData.isUpgradable,
          };
          res.vulnerabilities.push(tempVuln);
        }
      }
    }

    // copy cached results to final result arra
    resultCache.forEach(value => tempResultArray.push(value));

    return tempResultArray;
  };

  private getUniqueVulnerabilities(vulnerabilities: OssVulnerability[]): OssVulnerability[] {
    return vulnerabilities.filter((val, i, arr) => arr.findIndex(el => el.id === val.id) == i);
  }
}
