import { parse as jsParse, ParserPlugin } from '@babel/parser';
import traverse, { TraverseOptions } from '@babel/traverse';
import * as t from '@babel/types';
import { Identifier, ImportDeclaration, V8IntrinsicIdentifier } from '@babel/types';
import { glob } from 'glob';
import path from 'path';
import { JAVASCRIPT_FILE_REGEX, TYPESCRIPT_FILE_REGEX } from '../../../../common/constants/languageConsts';
import { ImportedModule, Language } from '../../../../common/types';
import { ModuleParser } from './moduleParser';

const PARSE_PLUGINS: ParserPlugin[] = [
  'jsx',
  'doExpressions',
  'objectRestSpread',
  'classProperties',
  'asyncGenerators',
  'functionBind',
  'functionSent',
  'dynamicImport',
];
const PARSE_JS_PLUGINS: ParserPlugin[] = ['flow', ...PARSE_PLUGINS];
const PARSE_TS_PLUGINS: ParserPlugin[] = ['typescript', ...PARSE_PLUGINS];

export class BabelParser extends ModuleParser {
  getModules(fileName: string, source: string, language: Language): ImportedModule[] {
    const modules: ImportedModule[] = [];
    const visitor = this.getVisitor(fileName, modules);

    const ast = this.parse(source, language);
    traverse(ast, visitor);

    return modules;
  }

  private getVisitor(fileName: string, modules: ImportedModule[]): TraverseOptions {
    return {
      ImportDeclaration({ node }): void {
        const target = `${path.dirname(fileName)}${path.sep}${node.source.value}`;

        if (!BabelParser.isLocalFile(target) && node.source.loc && node.loc) {
          modules.push({
            fileName,
            loc: node.source.loc,
            name: node.source.value,
            line: node.loc.end.line,
            string: BabelParser.compileImportString(node),
          });
        }
      },
      CallExpression({ node }) {
        if ((node.callee as V8IntrinsicIdentifier).name === 'require') {
          modules.push({
            fileName,
            name: BabelParser.getModuleName(node),
            line: node.loc ? node.loc.end.line : null,
            loc: node.arguments[0].loc,
            string: BabelParser.compileRequireString(node),
          });
        } else if (node.callee.type === 'Import') {
          modules.push({
            fileName,
            loc: node.arguments[0].loc,
            name: BabelParser.getModuleName(node),
            line: node.loc ? node.loc.end.line : null,
            string: BabelParser.compileImportExpressionString(node),
          });
        }
      },
    };
  }

  private parse(source: string, language: Language) {
    const plugins = language === Language.TypeScript ? PARSE_TS_PLUGINS : PARSE_JS_PLUGINS;
    return jsParse(source, {
      sourceType: 'module',
      plugins,
    });
  }

  private static isLocalFile(path: string): boolean {
    const foundFiles = [...glob.sync(`${path}/index.*`), ...glob.sync(`${path}.*`)];
    if (!foundFiles.length) {
      return false;
    }
    let fileExists = false;

    for (let idx = 0; idx < foundFiles.length; idx++) {
      const file = foundFiles[idx];
      if (TYPESCRIPT_FILE_REGEX.test(file) || JAVASCRIPT_FILE_REGEX.test(file)) {
        fileExists = true;
        break;
      }
    }

    return fileExists;
  }

  private static compileImportString(node: ImportDeclaration): string {
    let importSpecifiers: string | undefined;
    let importString: string;

    if (node.specifiers && node.specifiers.length > 0) {
      importString = node.specifiers
        .sort((s1, s2) => {
          // Import specifiers are in statement order, which for mixed imports must be either "defaultImport, * as namespaceImport"
          // or "defaultImport, { namedImport [as alias]... } according to current ECMA-262.
          // Given that two equivalent import statements can only differ in the order of the items in a NamedImports block,
          // we only need to sort these items in relation to each other to normalise the statements for caching purposes.
          // Where the node is anything other than ImportSpecifier (Babel terminology for NamedImports), preserve the original statement order.
          if (t.isImportSpecifier(s1) && t.isImportSpecifier(s2)) {
            return (s1.imported as Identifier).name < (s2.imported as Identifier).name ? -1 : 1;
          }
          return 0;
        })
        .map((specifier, i) => {
          if (t.isImportNamespaceSpecifier(specifier)) {
            return `* as ${specifier.local.name}`;
          } else if (t.isImportDefaultSpecifier(specifier)) {
            return specifier.local.name;
          } else if (t.isImportSpecifier(specifier)) {
            if (!importSpecifiers) {
              importSpecifiers = '{';
            }
            importSpecifiers += (specifier.imported as Identifier).name;
            if (node.specifiers[i + 1] && t.isImportSpecifier(node.specifiers[i + 1])) {
              importSpecifiers += ', ';
              return undefined;
            } else {
              const result = importSpecifiers + '}';
              importSpecifiers = undefined;
              return result;
            }
          } else {
            return undefined;
          }
        })
        .filter(x => x)
        .join(', ');
    } else {
      importString = '* as tmp';
    }
    return `import ${importString} from '${node.source.value}';\nconsole.log(${importString.replace('* as ', '')});`;
  }

  private static compileRequireString(node: t.CallExpression) {
    return `require('${this.getModuleName(node)}')`;
  }

  private static compileImportExpressionString(node: t.CallExpression) {
    return `import('${this.getModuleName(node)}').then(res => console.log(res));`;
  }

  private static getModuleName(node: t.CallExpression): string {
    return t.isTemplateLiteral(node.arguments[0])
      ? node.arguments[0].quasis[0].value.raw
      : (node.arguments[0] as t.StringLiteral).value;
  }
}
