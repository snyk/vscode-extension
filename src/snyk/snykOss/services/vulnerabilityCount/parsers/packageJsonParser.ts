import { ILog } from '../../../../common/logger/interfaces';
import { ImportedModule, OssRange } from '../../../../common/types';
import { ModuleParser } from './moduleParser';

export type PackageJsonDependencies = {
  [dependency: string]: string;
};

export interface PackageJson {
  dependencies: PackageJsonDependencies;
  devDependencies: PackageJsonDependencies;
}

export interface DependencyLines {
  lines: string[];
  offset: number;
}

export class PackageJsonParser extends ModuleParser {
  constructor(private readonly logger: ILog, private readonly cliParameters?: string) {
    super();
  }

  getModules(fileName: string, source: string): ImportedModule[] {
    const lines: string[] = [];
    source.split(/\r?\n/).forEach(function (line) {
      lines.push(line);
    });

    let pjson = null;

    try {
      pjson = JSON.parse(source) as PackageJson;
    } catch (err: unknown) {
      if (err instanceof Error) {
        this.logger.error(`Failed to parse package.json file: ${err.message}`);
      }
    }

    if (!pjson) {
      return [];
    }

    const depLines = this.findDependencyLines(pjson, 'dependencies', lines);
    const parseDevDeps = pjson.devDependencies && this.cliParameters?.includes('--dev');
    const devDepLines = parseDevDeps ? this.findDependencyLines(pjson, 'devDependencies', lines) : undefined;

    if (!depLines && !devDepLines) {
      return [];
    }

    const packages = [];

    if (depLines) {
      for (const dependency in pjson.dependencies) {
        packages.push(this.parseDependency(dependency, depLines, fileName));
      }
    }

    if (devDepLines) {
      for (const devDependency in pjson.devDependencies) {
        packages.push(this.parseDependency(devDependency, devDepLines, fileName));
      }
    }

    return packages;
  }

  private parseDependency(dependency: string, depLines: DependencyLines, fileName: string) {
    const loc = this.findRange(dependency, depLines.lines, depLines.offset);

    return {
      fileName,
      name: dependency,
      loc,
      line: loc?.start.line,
    } as ImportedModule;
  }

  private findDependencyLines(
    pjson: PackageJson,
    key: keyof PackageJson,
    lines: string[],
  ): DependencyLines | undefined {
    const depStartLine = lines.find(x => x.includes(`"${key}"`));
    if (!depStartLine) {
      return;
    }

    const dependencies = pjson[key];
    const depLineIndex = lines.indexOf(depStartLine) + 1;
    let dependenciesLength = Object.keys(dependencies).length;
    const emptyLineTabRegex = /(\t)$/;
    for (let i = depLineIndex + 1; i < lines.length - 1; i++) {
      if (emptyLineTabRegex.test(lines[i]) || !lines[i] || !lines[i].trim()) {
        dependenciesLength += 1;
        continue;
      }

      // end of dependencies.
      if (lines[i].includes('}')) {
        break;
      }
    }
    const depLines = lines.slice(depLineIndex, depLineIndex + dependenciesLength);

    return {
      lines: depLines,
      offset: depLineIndex,
    };
  }

  private findRange(dependency: string, lines: string[], offset: number): OssRange | undefined {
    const line = lines.find(x => x.includes('"' + dependency + '"'));
    if (!line) {
      return;
    }

    const index = offset + lines.indexOf(line) + 1;

    return {
      start: {
        line: index,
        column: line.indexOf('"'),
      },
      end: {
        line: index,
        column: line.length - 1,
      },
    };
  }
}
