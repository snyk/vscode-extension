import { ILog } from '../../../../common/logger/interfaces';
import { ImportedModule, OssRange } from '../../../../common/types';
import { ModuleParser } from './moduleParser';

export type PackageJsonDependencies = {
  [dependency: string]: string;
};

export interface PackageJson {
  dependencies: PackageJsonDependencies;
}

export interface DependencyLines {
  lines: string[];
  offset: number;
}

export class PackageJsonParser extends ModuleParser {
  constructor(private readonly logger: ILog) {
    super();
  }

  getModules(fileName: string, source: string): ImportedModule[] {
    const packages = [];

    const lines: string[] = [];
    source.split(/\r?\n/).forEach(function (line) {
      lines.push(line);
    });

    let pjson = null;

    try {
      pjson = JSON.parse(source) as PackageJson;
    } catch (err: unknown) {
      if (err instanceof Error) {
        this.logger.error(`Failed to parse package.json file: ${err.message}`);
      }
    }

    if (pjson) {
      const depLines = this.findDependecyLines(pjson.dependencies, lines);
      if (!depLines) {
        return [];
      }

      for (const dependency in pjson.dependencies) {
        const loc = this.findRange(dependency, depLines.lines, depLines.offset);

        const module = {
          fileName,
          name: dependency,
          loc,
          line: loc?.start.line,
        } as ImportedModule;

        packages.push(module);
      }
    }

    return packages;
  }

  private findDependecyLines(dependencies: PackageJsonDependencies, lines: string[]): DependencyLines | undefined {
    const depStartLine = lines.find(x => x.includes('"dependencies"'));
    if (!depStartLine) {
      return;
    }

    const depLineIndex = lines.indexOf(depStartLine) + 1;
    let dependenciesLength = Object.keys(dependencies).length;
    const emptyLineTabRegex = /(\t)$/;
    for (let i = depLineIndex + 1; i < lines.length - 1; i++) {
      if (emptyLineTabRegex.test(lines[i]) || !lines[i] || !lines[i].trim()) {
        dependenciesLength += 1;
        continue;
      }

      // end of dependencies.
      if (lines[i].includes('}')) {
        break;
      }
    }
    const depLines = lines.slice(depLineIndex, depLineIndex + dependenciesLength);

    return {
      lines: depLines,
      offset: depLineIndex,
    };
  }

  private findRange(dependency: string, lines: string[], offset: number): OssRange | undefined {
    const line = lines.find(x => x.includes('"' + dependency + '"'));
    if (!line) {
      return;
    }

    const index = offset + lines.indexOf(line) + 1;

    return {
      start: {
        line: index,
        column: line.indexOf('"'),
      },
      end: {
        line: index,
        column: line.length - 1,
      },
    };
  }
}
